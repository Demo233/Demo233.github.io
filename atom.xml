<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YIHAO&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="yihao.ml/"/>
  <updated>2020-11-15T10:13:04.604Z</updated>
  <id>yihao.ml/</id>
  
  <author>
    <name>Yihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="yihao.ml/2020/11/15/2020%E5%B9%B411%E6%9C%8815%E6%97%A516:09:43_Docker%E5%AE%89%E8%A3%85mysql/"/>
    <id>yihao.ml/2020/11/15/2020年11月15日16:09:43_Docker安装mysql/</id>
    <published>2020-11-15T10:13:04.604Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker部署hadoop</title>
    <link href="yihao.ml/2020/11/15/2020%E5%B9%B411%E6%9C%8815%E6%97%A514:11:53_%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop/"/>
    <id>yihao.ml/2020/11/15/2020年11月15日14:11:53_使用docker部署hadoop/</id>
    <published>2020-11-15T10:13:04.604Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --><p>首先我们构建一个jdk1.8+centos基础镜像，由于网上已经有很多现成的轮子，这里就不自己造了</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ryaning/centos-ssh</span><br></pre></td></tr></table></figure><h2 id="一-构建基础镜像"><a class="markdownIt-Anchor" href="#一-构建基础镜像"></a> 一、构建基础镜像</h2><p>如果镜像下载不下来，可以使用下面方法自己创建基础镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 Dockerfile</span></span><br><span class="line">vi Dockerfile</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">新增以下内容</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基础镜像</span></span><br><span class="line">FROM ryaning/centos-ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 作者</span></span><br><span class="line">MAINTAINER  Ryan &lt;me@ryana.cn&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">ADD jdk-8u162-linux-x64.tar.gz /usr/local/</span><br><span class="line">RUN mv /usr/local/jdk1.8.0_162 /usr/local/jdk1.8</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">ADD hadoop-2.9.2.tar.gz /usr/local</span><br><span class="line">RUN mv /usr/local/hadoop-2.9.2 /usr/local/hadoop</span><br><span class="line">ENV HADOOP_HOME /usr/local/hadoop</span><br><span class="line">ENV PATH $HADOOP_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">RUN yum install -y which sudo</span><br></pre></td></tr></table></figure><h2 id="二-搭建hadoop集群"><a class="markdownIt-Anchor" href="#二-搭建hadoop集群"></a> 二、 搭建hadoop集群</h2><h3 id="规划"><a class="markdownIt-Anchor" href="#规划"></a> 规划</h3><p>准备搭建一个具有三个节点的集群,1 master 2 slave</p><ul><li>master: hadoop0 ip: 192.168.10.10</li><li>salve1: hadoop1 ip: 192.168.10.11</li><li>salve2: hadoop2 ip: 192.168.10.12</li></ul><h3 id="配置ip"><a class="markdownIt-Anchor" href="#配置ip"></a> 配置IP</h3><p>docker 容器在启动时默认使用的是 bridge 模式，docker 容器启动后，会连接到一个名为 docker0 的虚拟网桥，故每次启动 docker 容器的 IP 都不是固定的，不方便管理，有时候需要进行固定 IP 映射，比如 docker 集群管理时。docker 在 1.9 版本版后，提供了创建自定义网络功能命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建自定义网络 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip段为：192.168.10.1/24，名字为：hadoop</span></span><br><span class="line">docker network create --subnet=192.168.10.1/24 hadoop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示自定义网络列表</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>运行3个 hadoop 容器，分别命名为 hadoop0，hadoop1，hadoop2，其中 hadoop0 作为 master， 并且映射了端口号，50070 和 8088，用来在浏览器中访问 hadoop WEB 界面的。</p><h4 id="命令说明"><a class="markdownIt-Anchor" href="#命令说明"></a> 命令说明：</h4><ul><li>-e TZ=“Asia/Shanghai” 增加环境变量，指定时区</li><li>-v /etc/localtime:/etc/localtime:ro：挂载系统时间到容器内</li><li>–net hadoop --ip 192.168.10.10：配置 Hadoop 集群节点的固定 IP</li><li>–add-host hadoop1:192.168.10.11：除了需要配置好 Hadoop 集群节点的固定 IP 外，还需要修改 Hadoop 容器内部的 hosts 文件，设置主机名与 ip 的映射。在 docker 中直接修改 /etc/hosts 文件，在重启容器后会被重置、覆盖。因此需要通过容器启动脚本 docker run 的 --add-host 参数将主机和 ip 地址的对应关系传入，容器在启动后会写入 hosts 文件中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hadoop0</span></span><br><span class="line">docker run --name hadoop0 \</span><br><span class="line">--hostname hadoop0 \</span><br><span class="line">--net hadoop --ip 192.168.10.10 \</span><br><span class="line">--add-host hadoop1:192.168.10.11 \</span><br><span class="line">--add-host hadoop2:192.168.10.12 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-d -P ryaning/hadoop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> hadoop1</span></span><br><span class="line">docker run --name hadoop1 \</span><br><span class="line">--hostname hadoop1 \</span><br><span class="line">--net hadoop --ip 192.168.10.11 \</span><br><span class="line">--add-host hadoop0:192.168.10.10 \</span><br><span class="line">--add-host hadoop2:192.168.10.12 \</span><br><span class="line">-d -P ryaning/hadoop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> hadoop2</span></span><br><span class="line">docker run --name hadoop2 \</span><br><span class="line">--hostname hadoop2 \</span><br><span class="line">--net hadoop --ip 192.168.10.12 \</span><br><span class="line">--add-host hadoop0:192.168.10.10 \</span><br><span class="line">--add-host hadoop1:192.168.10.11 \</span><br><span class="line">-d -P ryaning/hadoop</span><br></pre></td></tr></table></figure><h3 id="设置-ssh-免密码登录"><a class="markdownIt-Anchor" href="#设置-ssh-免密码登录"></a> 设置 SSH 免密码登录</h3><p>前面已经为容器配置 IP 了，在进行 ssh 时需要输入要登陆的容器的 root 密码，Hadoop 集群要求集群间机器 SSH 连接时无密码登陆，下面讲述容器间如何配置 SSH 无密码登陆。</p><p>以 hadoop0 容器为例，hadoop1、hadoop2 容器同样需要修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 hadoop0 容器内</span></span><br><span class="line">docker exec -it hadoop0 bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后会有多个输入提示，不用输入任何内容，全部直接回车即可</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令后需要输入登录密码，**默认为 123456**</span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop0</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop1</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop2</span><br></pre></td></tr></table></figure><h3 id="修改-hadoop-配置文件"><a class="markdownIt-Anchor" href="#修改-hadoop-配置文件"></a> 修改 Hadoop 配置文件</h3><p>要想真正的运行 hadoop 应用还需要修改 hadoop 运行参数；以 hadoop0 为例，进入到容器内 /usr/local/hadoop/etc/hadoop 目录下，需要修改的可执行文件与配置文件包括：<a href="http://hadoop-env.sh" target="_blank" rel="noopener">hadoop-env.sh</a>、<a href="http://yarn-env.sh" target="_blank" rel="noopener">yarn-env.sh</a>、core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml。</p><ul><li><a href="http://hadoop-env.sh" target="_blank" rel="noopener">hadoop-env.sh</a></li></ul><p>注释掉原有的配置 export JAVA_HOME=${JAVA_HOME}，修改成当前的 export JAVA_HOME=/usr/local/jdk1.8。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* yarn-env.sh</span><br><span class="line"></span><br><span class="line">同样是重新指定 export JAVA_HOME=/usr/local/jdk1.8。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/jdk1.8</span><br></pre></td></tr></table></figure><ul><li>core-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 HDFS 中 NameNode 的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop0:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 hadoop 运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.trash.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>1440<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>hdfs-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yarn-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mapred-site.xml</li></ul><p>这个文件默认不存在，需要从 mapred-site.xml.template 复制过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>slaves 配置</li></ul><p>修改 hadoop0 中的从机（slaves）配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vi /usr/local/hadoop/etc/hadoop/slaves</span><br></pre></td></tr></table></figure><p>删除原来的所有内容，修改为如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop1</span><br><span class="line">hadoop2</span><br></pre></td></tr></table></figure><h3 id="hadoop-集群配置分发"><a class="markdownIt-Anchor" href="#hadoop-集群配置分发"></a> hadoop 集群配置分发</h3><p>在 hadoop0 中执行命令，将 hadoop0 中的配置复制到其他两个节点中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/local/hadoop hadoop1:/usr/local</span><br><span class="line">scp -r /usr/local/hadoop hadoop2:/usr/local</span><br></pre></td></tr></table></figure><h2 id="三-启动"><a class="markdownIt-Anchor" href="#三-启动"></a> 三、启动</h2><p>第一次启动集群时，需要初始化</p><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p>出现类似下面命令说明格式化成功。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/15/Snipaste_2020-11-15_14-51-19-1605424306303.png" alt="title"></p><blockquote><p>注：格式化操作不能重复执行。如果一定要重复格式化，带参数 -force 即可。</p></blockquote><h3 id="启动-hadoop-集群"><a class="markdownIt-Anchor" href="#启动-hadoop-集群"></a> 启动 hadoop 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/<span class="built_in">local</span>/hadoop 目录下执行</span></span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>注：在主节点 hadoop0 启动 hadoop，从节点 hadoop1、hadoop2 会自动启动。</p><p>浏览器中访问</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/15/Snipaste_2020-11-15_15-13-58-1605424469022.png" alt="title"></p><h2 id="四-验证集群是否正常"><a class="markdownIt-Anchor" href="#四-验证集群是否正常"></a> 四、验证集群是否正常</h2><p>可以正常访问的话，说明集群启动成功了，但不一定能正常运行，还需要下面的实际验证。</p><h3 id="测试验证"><a class="markdownIt-Anchor" href="#测试验证"></a> 测试验证</h3><p>创建本地测试文件，在 /opt 目录下创建测试文件目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir wcinput</span><br><span class="line">cd wcinput</span><br><span class="line">vi wc.input</span><br></pre></td></tr></table></figure><p>wc.input文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop mapreduce</span><br><span class="line">hadoop yarn</span><br><span class="line">hadoop hdfs</span><br><span class="line">mapreduce spark</span><br><span class="line">hadoop hello</span><br></pre></td></tr></table></figure><p>创建 HDFS 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /user/hadoop/input</span><br></pre></td></tr></table></figure><p>上传文件，把测试文件上传到刚刚创建的目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put /opt/wcinput/wc.input /user/hadoop/input</span><br></pre></td></tr></table></figure><p>查看文件上传是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /user/hadoop/input</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -ls /user/hadoop/input</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--   1 root supergroup         70 2019-01-21 10:07 /user/hadoop/input/wc.input</span><br><span class="line">[root@hadoop0 wcinput]#</span><br></pre></td></tr></table></figure><p>运行 mapreduce 程序</p><p>hadoop 安装包中提供了一个示例程序，我们可以使用它对刚刚上传的文件进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount /user/hadoop/input /user/hadoop/output</span><br></pre></td></tr></table></figure><blockquote><p>注：在执行过程中，如果长时间处于 Running 状态不动，虽然没有报错，但实际上是出错了，后台在不断重试，需要到 logs 目录下（/usr/local/hadoop/logs）查看日志文件中的错误信息。</p></blockquote><p>查看输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /user/hadoop/output</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -ls /user/hadoop/output</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 root supergroup          0 2019-01-22 05:35 /user/hadoop/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 root supergroup         51 2019-01-22 05:35 /user/hadoop/output/part-r-00000</span><br></pre></td></tr></table></figure><p>_SUCCESS 表示 HDFS 文件状态，生成的结果在 part-r-00000 中查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat /user/hadoop/output/part-r-00000</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -cat /user/hadoop/output/part-r-00000</span><br><span class="line">hadoop    4</span><br><span class="line">hdfs    1</span><br><span class="line">hello    1</span><br><span class="line">mapreduce    2</span><br><span class="line">spark    1</span><br><span class="line">yarn    1</span><br><span class="line">[root@hadoop0 wcinput]#</span><br></pre></td></tr></table></figure><p>以上就是使用 Docker 环境搭建 Hadoop 镜像容器，配置 Hadoop 集群，并启动和测试的实例，测试用的是 hadoop 官方给的一个 wordcount 统计，利用 hadoop 安装包里的 mapreduce 示例 jar 计算指定 HDFS 文件里的单词数，并将结果输出到指定 HDFS 目录。后面会介绍 HDFS 常用文件操作命令。</p><p>links: <a href="https://book.ryana.cn/hadoop/docker-install-hadoop.html" target="_blank" rel="noopener">https://book.ryana.cn/hadoop/docker-install-hadoop.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --&gt;&lt;p&gt;首先我们构建一个jdk1.8+centos基础镜像，由于网上已经有很多现成的轮子，这里就不自己造了&lt;/p&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>高效VIM编辑器</title>
    <link href="yihao.ml/2020/11/15/%202020%E5%B9%B411%E6%9C%8815%E6%97%A513:38:15_%E9%AB%98%E6%95%88VIM%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>yihao.ml/2020/11/15/ 2020年11月15日13:38:15_高效VIM编辑器/</id>
    <published>2020-11-15T10:13:04.604Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率</p><h2 id="vim-中自定义快捷键"><a class="markdownIt-Anchor" href="#vim-中自定义快捷键"></a> Vim 中自定义快捷键</h2><p>map系列命令<br>这个命令的声明如下: :map {lhs} {rhs}。这个命令就是将{lhs}代表的按键映射成{rhs}所代表的按键。例如map L 就是将键映射成L。此外需要注意的是map命令定义的快捷键是可以嵌套的，例如下面这样的命令:</p><p>map L $<br>map Y yL</p><p>就是将Y按键映射成了y$按键。</p><p>更多详情参考:<a href="https://www.cnblogs.com/boldness2012/p/12432792.html" target="_blank" rel="noopener">https://www.cnblogs.com/boldness2012/p/12432792.html</a></p><h2 id="vim默认设置"><a class="markdownIt-Anchor" href="#vim默认设置"></a> Vim默认设置</h2><p>在<code>.vimrc</code>文件中添加下面内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用高亮</span></span><br><span class="line">syntax <span class="built_in">enable</span>                                                                                                           </span><br><span class="line"><span class="comment"># 设置行号</span></span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="comment"># 设置卡尺</span></span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="comment"># 高亮当前行</span></span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="comment"># F4 格式化JSON内容</span></span><br><span class="line">map &lt;F4&gt; &lt;Esc&gt;:%!python -m json.tool&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>第8行是格式化json的快捷键设置，在vim模式下按F4即可格式化Json数据</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率&lt;/p&gt;&lt;h2 id=&quot;vim-中自定义快捷键&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Linux" scheme="yihao.ml/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>testautodeploy</title>
    <link href="yihao.ml/2020/11/15/newnote_1605418220005/"/>
    <id>yihao.ml/2020/11/15/newnote_1605418220005/</id>
    <published>2020-11-15T05:33:47.954Z</published>
    <updated>2020-11-15T05:36:10.082Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>11111123123123123123</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;11111123123123123123&lt;/p&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Linux" scheme="yihao.ml/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>微服务Cloud之Docker</title>
    <link href="yihao.ml/2020/11/15/2020%E2%80%9309-19-%E5%BE%AE%E6%9C%8D%E5%8A%A1Cloud%E4%B9%8BDocker/"/>
    <id>yihao.ml/2020/11/15/2020–09-19-微服务Cloud之Docker/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --><p><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586333742105.png" alt="1586333742105"></p><blockquote><p>Author：Eric</p><p>Version：9.0.1</p><p>From : 转载</p></blockquote><p>看到Eric哥们在b站中分享的Docker视频，觉得讲的很好，这里提供一下讲义方便大家学习。</p><p>[TOC]</p><h3 id="一-引言"><a class="markdownIt-Anchor" href="#一-引言"></a> 一、引言</h3><hr><h4 id="11-环境不一致"><a class="markdownIt-Anchor" href="#11-环境不一致"></a> 1.1 环境不一致</h4><blockquote><p>我本地运行没问题啊：由于环境不一致，导致相同的程序，运行结果却不一致。</p></blockquote><h4 id="12-隔离性"><a class="markdownIt-Anchor" href="#12-隔离性"></a> 1.2 隔离性</h4><blockquote><p>哪个哥们又写死循环了，怎么这么卡：在多用户的操作系统下，会因为其他用户的操作失误影响到你自己编写的程序。</p></blockquote><h4 id="13-弹性伸缩"><a class="markdownIt-Anchor" href="#13-弹性伸缩"></a> 1.3 弹性伸缩</h4><blockquote><p>淘宝在双11，用户量暴增：需要很多很多的运维人员去增加部署的服务器，运维成本过高。</p></blockquote><h4 id="14-学习成本"><a class="markdownIt-Anchor" href="#14-学习成本"></a> 1.4 学习成本</h4><blockquote><p>学习一门技术，得先安装啊：学习每一门技术都要先安装响应的软件，但是还有他所依赖的各种环境，安装软件成本快高过学习成本啦。</p></blockquote><h3 id="二-docker介绍"><a class="markdownIt-Anchor" href="#二-docker介绍"></a> 二、Docker介绍</h3><hr><h4 id="21-docker的由来"><a class="markdownIt-Anchor" href="#21-docker的由来"></a> 2.1 Docker的由来</h4><blockquote><p>Docker 最初是 dotCloud 公司创始人Solomon Hykes 在法国期间发起的一个公司内部项目。</p><p>2010年的专门做PAAS平台，但是到了2013年的时候，像亚马逊，微软，Google都开始做PAAS平台。</p><p>到了2013年，公司资金链断裂，不得不倒闭，于是将公司内的核心技术对外开源，核心技术就是Docker。</p><p>由于开源了Docker，到了2014年的时候，得到了各轮融资，于是公司开始全神贯注的维护Docker。</p></blockquote><table><thead><tr><th style="text-align:center">Docker主要作者-Solomon</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586340594252.png" alt="1586340594252"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">现在Solomon已经离开了维护Docker的团队</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586340639934.png" alt="1586340639934"></td></tr></tbody></table><h4 id="22-docker的思想"><a class="markdownIt-Anchor" href="#22-docker的思想"></a> 2.2 Docker的思想</h4><blockquote><ul><li><p>封装：将需要的操作系统，环境，软件封装到一个镜像中。</p></li><li><p>标准化：</p><ul><li>运输的标准化：Docker提供了中央仓库，所有官方的镜像都放在了这个中央仓库中，当需要使用某一个镜像时，通过相应的方式拉取即可。</li><li>命令的标准化：Docker提供了一些列的命令，帮助我们去获取镜像，管理容器等等操作。</li><li>提供了REST的API：基于标准REST的API衍生出了很多的图形化界面，如Rancher等。</li></ul></li><li><p>隔离性：Docker在运行镜像时，会在Linux的内核中，单独的开辟一片空间，这片空间不会影响到其他程序。</p></li></ul></blockquote><h3 id="三-docker的安装"><a class="markdownIt-Anchor" href="#三-docker的安装"></a> 三、Docker的安装</h3><hr><h4 id="31-下载docker依赖的环境"><a class="markdownIt-Anchor" href="#31-下载docker依赖的环境"></a> 3.1 下载Docker依赖的环境</h4><blockquote><p>安装Docker，需要先将依赖的环境全部下载，就像Maven依赖JDK一样。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="32-指定docker镜像源"><a class="markdownIt-Anchor" href="#32-指定docker镜像源"></a> 3.2 指定Docker镜像源</h4><blockquote><p>默认情况下，下载Docker会从国外服务器下载，速度较慢，我们可以设置为阿里云镜像源，速度更快。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="33-安装docker"><a class="markdownIt-Anchor" href="#33-安装docker"></a> 3.3 安装Docker</h4><blockquote><p>采用yum的方式安装。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>Docker 安装不了可能是源的问题,我的机器是ubuntu，这里参考了链接完成了安装https://www.runoob.com/docker/ubuntu-docker-install.html</p><h4 id="34-启动docker并测试"><a class="markdownIt-Anchor" href="#34-启动docker并测试"></a> 3.4 启动Docker并测试</h4><blockquote><p>安装成功后，需要手动启动，设置为开机自启，并测试。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="四-docker的中央仓库重点"><a class="markdownIt-Anchor" href="#四-docker的中央仓库重点"></a> 四、Docker的中央仓库【<code>重点</code>】</h3><hr><blockquote><ul><li><p>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。</p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p></li><li><p>国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。</p><p><a href="https://c.163yun.com/hub#/home" target="_blank" rel="noopener">https://c.163yun.com/hub#/home</a></p><p><a href="http://hub.daocloud.io/" target="_blank" rel="noopener">http://hub.daocloud.io/</a> （推荐使用）</p></li><li><p>在公司内部会采用私服的方式拉取镜像，需要添加配置，如下……</p></li></ul></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 需要创建或修改/etc/docker/daemon.json，并添加如下内容，"ip:port"可以编写多个。</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line"><span class="attr">"insecure-registries"</span>: [<span class="string">"ip:port"</span>]   </span><br><span class="line">&#125;</span><br><span class="line"># 重启docker服务</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="五-镜像的操作"><a class="markdownIt-Anchor" href="#五-镜像的操作"></a> 五、镜像的操作</h3><hr><h4 id="51-拉取镜像"><a class="markdownIt-Anchor" href="#51-拉取镜像"></a> 5.1 拉取镜像</h4><blockquote><p>从中央仓库拉取镜像到本地</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个栗子：docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></span><br></pre></td></tr></table></figure><h4 id="52-查看本地全部镜像"><a class="markdownIt-Anchor" href="#52-查看本地全部镜像"></a> 5.2 查看本地全部镜像</h4><blockquote><p>查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h4 id="53-删除本地镜像"><a class="markdownIt-Anchor" href="#53-删除本地镜像"></a> 5.3 删除本地镜像</h4><blockquote><p>镜像会占用磁盘空间，可以直接手动删除，表示通过查看获取</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像的标识 | 镜像名称:tag</span><br><span class="line">docker rmi b8dfe9ade316</span><br><span class="line">docker rmi daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><h4 id="54-镜像的导入导出"><a class="markdownIt-Anchor" href="#54-镜像的导入导出"></a> 5.4 镜像的导入导出</h4><blockquote><ul><li>如果出现网络故障，可以采过硬盘的方式传输镜像，虽然不规范，但是有效。</li><li>但是这种方式导出的镜像名称和版本都是null，需要手动修改</li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line">doeker save -o /usr/<span class="built_in">local</span>/abc.tar b8dfe9ade316</span><br><span class="line"><span class="comment"># 加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line">docker load -i /usr/<span class="built_in">local</span>/abc.tar</span><br><span class="line"><span class="comment"># 修改镜像名称</span></span><br><span class="line">docker tag 镜像id 新镜像名称:版本</span><br><span class="line">docker tag b8dfe9ade316  mytomcat:1.0</span><br></pre></td></tr></table></figure><h3 id="六-容器操作重点"><a class="markdownIt-Anchor" href="#六-容器操作重点"></a> 六、容器操作【<code>重点</code>】</h3><hr><h4 id="61-运行容器"><a class="markdownIt-Anchor" href="#61-运行容器"></a> 6.1 运行容器</h4><blockquote><p>运行容器需要指定具体镜像，如果镜像不存在，会直接下载</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单操作</span></span><br><span class="line">docker run 镜像的标识 | 镜像名称[:tag]</span><br><span class="line">docker run b8dfe9ade316</span><br><span class="line">docker run daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line"><span class="comment"># 常用的参数</span></span><br><span class="line">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span><br><span class="line">docker run -d -p 8090:8080 --name my_container b8dfe9ade316</span><br><span class="line"><span class="comment"># -d：代表后台运行容器</span></span><br><span class="line"><span class="comment"># -p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span></span><br><span class="line"><span class="comment"># --name 容器名称：指定容器的名称</span></span><br></pre></td></tr></table></figure><h4 id="62-查看正在运行的容器"><a class="markdownIt-Anchor" href="#62-查看正在运行的容器"></a> 6.2 查看正在运行的容器</h4><blockquote><p>查看全部正在运行的容器信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps [-qa]</span><br><span class="line"><span class="comment"># -a：查看全部的容器，包括没有运行</span></span><br><span class="line"><span class="comment"># -q：只查看容器的标识</span></span><br></pre></td></tr></table></figure><h4 id="63-查看容器日志"><a class="markdownIt-Anchor" href="#63-查看容器日志"></a> 6.3 查看容器日志</h4><blockquote><p>查看容器日志，以查看容器运行的信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器id</span><br><span class="line"><span class="comment"># -f：可以滚动查看日志的最后几行</span></span><br></pre></td></tr></table></figure><h4 id="64-进入容器内容部"><a class="markdownIt-Anchor" href="#64-进入容器内容部"></a> 6.4 进入容器内容部</h4><blockquote><p>可以进入容器内部进行操作</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器id bash</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称 bash</span><br></pre></td></tr></table></figure><h4 id="65-复制内容到容器"><a class="markdownIt-Anchor" href="#65-复制内容到容器"></a> 6.5 复制内容到容器</h4><blockquote><p>将宿主机的文件复制到容器内部的指定目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br></pre></td></tr></table></figure><h4 id="66-重启启动停止删除容器"><a class="markdownIt-Anchor" href="#66-重启启动停止删除容器"></a> 6.6 重启&amp;启动&amp;停止&amp;删除容器</h4><blockquote><p>容器的启动，停止，删除等操作，后续经常会使用到</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动停止运行的容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器（删除容器前，需要先停止容器）</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="comment"># 停止全部容器</span></span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="comment"># 删除全部容器</span></span><br><span class="line">docker rm $(docker ps -qa)</span><br></pre></td></tr></table></figure><h3 id="七-docker应用"><a class="markdownIt-Anchor" href="#七-docker应用"></a> 七、Docker应用</h3><hr><h4 id="71-docker安装tomcat"><a class="markdownIt-Anchor" href="#71-docker安装tomcat"></a> 7.1 Docker安装Tomcat</h4><blockquote><p>运行Tomcat容器，为部署SSM工程做准备</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name tomcat daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><h4 id="72-docker安装mysql"><a class="markdownIt-Anchor" href="#72-docker安装mysql"></a> 7.2 Docker安装MySQL</h4><blockquote><p>运行MySQL容器，为部署SSM工程做准备</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3366:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 宿主机中通过 3366连接 容器中的mysql</span></span><br><span class="line">[root@localhost logs]<span class="comment"># mysql -uroot -P 3366 -proot -h 192.168.1.135</span></span><br></pre></td></tr></table></figure><h4 id="73-部署ssm工程"><a class="markdownIt-Anchor" href="#73-部署ssm工程"></a> 7.3 部署SSM工程</h4><blockquote><ul><li>修改SSM工程环境，设置为Linux中Docker容器的信息</li><li>通过Maven的package重新打成war包</li><li>将Windows下的war包复制到Linux中</li><li>通过docker命令将宿主机的war包复制到容器内部</li><li>测试访问SSM工程</li></ul></blockquote><h3 id="八-数据卷重点"><a class="markdownIt-Anchor" href="#八-数据卷重点"></a> 八、数据卷【<code>重点</code>】</h3><hr><blockquote><ul><li><p>为部署SSM的工程，需要使用到Docker的cp命令将宿主机内的ssm.war文件复制到容器内部，操作麻烦。</p></li><li><p><a href>数据卷</a>：</p></li><li><p>将宿主机的一个目录映射到容器的一个目录中。</p></li><li><p>可以在宿主机中操作目录中的内容，容器内部映射的文件会跟着一起改变。</p></li></ul></blockquote><h4 id="81-创建数据卷"><a class="markdownIt-Anchor" href="#81-创建数据卷"></a> 8.1 创建数据卷</h4><blockquote><p>创建数据卷之后，默认会存放在一个目录下 /var/lib/docker/volumes/数据卷名称/_data</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="82-查看数据卷详情"><a class="markdownIt-Anchor" href="#82-查看数据卷详情"></a> 8.2 查看数据卷详情</h4><blockquote><p>查看数据卷的详细信息，可以查询到存放路径，创建时间等等</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="83-查看全部数据卷"><a class="markdownIt-Anchor" href="#83-查看全部数据卷"></a> 8.3 查看全部数据卷</h4><blockquote><p>查看全部数据卷信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h4 id="84-删除数据卷"><a class="markdownIt-Anchor" href="#84-删除数据卷"></a> 8.4 删除数据卷</h4><blockquote><p>删除指定数据卷</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="85-容器映射数据卷"><a class="markdownIt-Anchor" href="#85-容器映射数据卷"></a> 8.5 容器映射数据卷</h4><blockquote><p>映射有两种方式：</p><ul><li>通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</li><li>通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过数据卷名称映射</span></span><br><span class="line">docker run -v 数据卷名称:容器内部的路径 镜像id</span><br><span class="line">docker run -v webapps2004:/usr/<span class="built_in">local</span>/tomcat/webappss 镜像id</span><br><span class="line"><span class="comment"># 通过路径映射数据卷</span></span><br><span class="line">docker run -v 路径:容器内部的路径 镜像id</span><br><span class="line">docker run -v /usr/<span class="built_in">local</span>/tomcat_webapps2004:/usr/<span class="built_in">local</span>/tomcat/webapps 镜像id</span><br></pre></td></tr></table></figure><h3 id="九-dockerfile自定义镜像重点"><a class="markdownIt-Anchor" href="#九-dockerfile自定义镜像重点"></a> 九、Dockerfile自定义镜像【<code>重点</code>】</h3><hr><blockquote><p>我们可以从中央仓库下载一个镜像，也可以自己手动去制作一个镜像，需要通过Dockerfile去指定自定义镜像的信息</p></blockquote><h4 id="91-dockerfile"><a class="markdownIt-Anchor" href="#91-dockerfile"></a> 9.1 Dockerfile</h4><blockquote><p>创建自定义镜像就需要创建一个Dockerfile，如下为Dockerfile的常用配置</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from: 指定当前自定义镜像依赖的环境</span><br><span class="line">copy: 将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir: 声明镜像的默认工作目录</span><br><span class="line">run: 执行的命令，可以编写多个</span><br><span class="line">cmd: 需要执行的命令（在workdir下执行的，cmd可以写多个，但是只以最后一个为准）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个例子，制作SSM容器镜像，而且ssm.war要放在Dockerfile的同级目录下</span></span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure><h4 id="92-通过dockerfile制作镜像"><a class="markdownIt-Anchor" href="#92-通过dockerfile制作镜像"></a> 9.2 通过Dockerfile制作镜像</h4><blockquote><p>编写完Dockerfile后需要Dockerfile所在目录通过命令将其制作为镜像，注意最后的 <a href>.</a> 代表当前目录。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:tag] .</span><br></pre></td></tr></table></figure><h3 id="十-docker-compose重点"><a class="markdownIt-Anchor" href="#十-docker-compose重点"></a> 十. Docker-Compose【<code>重点</code>】</h3><hr><blockquote><ul><li>运行一个容器，我们需要添加大量的参数，可以通过Docker-Compose文件配置参数。</li><li>参数信息通过docker-compose.yml文件去维护。</li><li>Docker-Compose可以批量管理容器。</li></ul></blockquote><h4 id="101-下载并安装docker-compose"><a class="markdownIt-Anchor" href="#101-下载并安装docker-compose"></a> 10.1 下载并安装Docker-Compose</h4><h5 id="1011-下载docker-compose"><a class="markdownIt-Anchor" href="#1011-下载docker-compose"></a> 10.1.1 下载Docker-Compose</h5><blockquote><p>去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</p><p>下载路径：<a href>https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</a></p></blockquote><h5 id="1012-设置权限"><a class="markdownIt-Anchor" href="#1012-设置权限"></a> 10.1.2 设置权限</h5><blockquote><p>需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br></pre></td></tr></table></figure><h5 id="1013-移动到usrlocalbin目录下"><a class="markdownIt-Anchor" href="#1013-移动到usrlocalbin目录下"></a> 10.1.3 移动到/usr/local/bin目录下</h5><blockquote><p>方便后期操作，将docker-compose文件移动到了/usr/local/bin</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv docker-compose /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><h5 id="1014-测试"><a class="markdownIt-Anchor" href="#1014-测试"></a> 10.1.4 测试</h5><blockquote><p>在任意目录下输入docker-compose</p></blockquote><table><thead><tr><th style="text-align:center">测试效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586420176720.png" alt="1586420176720"></td></tr></tbody></table><h4 id="102-docker-compose管理mysql和tomcat容器"><a class="markdownIt-Anchor" href="#102-docker-compose管理mysql和tomcat容器"></a> 10.2 Docker-Compose管理MySQL和Tomcat容器</h4><blockquote><ul><li><p>yml文件以key: value方式来指定配置信息</p></li><li><p>多个配置信息以换行+缩进的方式来区分</p></li><li><p>在docker-compose.yml文件中，不要使用制表符</p></li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql:</span>           <span class="comment"># 服务的名称</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span>   <span class="comment"># 代表只要docker启动，那么这个容器就跟着一起启动</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">daocloud.io/library/mysql:5.7.4</span>  <span class="comment"># 指定镜像路径</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">mysql</span>  <span class="comment"># 指定容器名称</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">3306</span><span class="string">:3306</span>   <span class="comment">#  指定端口号的映射</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span>   <span class="comment"># 指定MySQL的ROOT用户登录密码</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span>        <span class="comment"># 指定时区</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql</span>   <span class="comment"># 映射数据卷</span></span><br><span class="line"><span class="attr">  tomcat:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span></span><br></pre></td></tr></table></figure><h4 id="103-使用docker-compose命令管理容器"><a class="markdownIt-Anchor" href="#103-使用docker-compose命令管理容器"></a> 10.3 使用docker-compose命令管理容器</h4><blockquote><p>在docker-compose.yml文件目录下使用docker-compose的命令时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于docker-compose.yml启动管理的容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 关闭并删除容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 开启|关闭|重启已经存在的由docker-compose维护的容器</span></span><br><span class="line">docker-compose start|stop|restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看由docker-compose管理的容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 查看日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h4 id="104-docker-compose配合dockerfile使用"><a class="markdownIt-Anchor" href="#104-docker-compose配合dockerfile使用"></a> 10.4 docker-compose配合Dockerfile使用</h4><blockquote><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器</p></blockquote><h5 id="1041-docker-compose文件"><a class="markdownIt-Anchor" href="#1041-docker-compose文件"></a> 10.4.1 docker-compose文件</h5><blockquote><p>编写docker-compose.yml文件</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  ssm:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    build:</span>            <span class="comment"># 构建自定义镜像</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">../</span>      <span class="comment"># 指定dockerfile文件的所在路径</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile</span>   <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">ssm:1.0.1</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">ssm</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8081</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h5 id="1042-dockerfile文件"><a class="markdownIt-Anchor" href="#1042-dockerfile文件"></a> 10.4.2 Dockerfile文件</h5><blockquote><p>编写Dockerfile文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h5 id="1043-运行"><a class="markdownIt-Anchor" href="#1043-运行"></a> 10.4.3 运行</h5><blockquote><p>测试效果</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建自定义镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行当前内容，并重新构建</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><h3 id="十一-docker-ci-cd"><a class="markdownIt-Anchor" href="#十一-docker-ci-cd"></a> 十一. Docker CI、CD</h3><hr><h4 id="111-ci-cd引言"><a class="markdownIt-Anchor" href="#111-ci-cd引言"></a> 11.1 CI、CD引言</h4><blockquote><p>项目部署</p><ul><li>将项目通过maven进行编译打包</li><li>将文件上传到指定的服务器中</li><li>将war包放到tomcat的目录中</li><li>通过Dockerfile将Tomcat和war包转成一个镜像，由DockerCompose去运行容器</li></ul><p>项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过CI、CD帮助我们实现持续集成，持续交付和部署。</p></blockquote><h4 id="112-ci介绍"><a class="markdownIt-Anchor" href="#112-ci介绍"></a> 11.2 CI介绍</h4><blockquote><p>CI（continuous intergration）持续集成</p><p>持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试。</p><ul><li>快速发现错误。</li><li>防止代码偏离主分支。</li></ul></blockquote><h4 id="113-搭建gitlab服务器"><a class="markdownIt-Anchor" href="#113-搭建gitlab服务器"></a> 11.3 搭建Gitlab服务器</h4><blockquote><p>实现CI，需要使用到Gitlab远程仓库，先通过Docker搭建Gitlab</p></blockquote><h5 id="1131-准备工作"><a class="markdownIt-Anchor" href="#1131-准备工作"></a> 11.3.1 准备工作</h5><blockquote><ul><li>创建一个全新的虚拟机，并且至少指定4G的运行内存，4G运行内存是Gitlab推荐的内存大小。</li><li>并且安装Docker以及Docker-Compose</li></ul></blockquote><h5 id="1132-修改ssh的22端口"><a class="markdownIt-Anchor" href="#1132-修改ssh的22端口"></a> 11.3.2 修改ssh的22端口</h5><blockquote><p>将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">  PORT 22 -&gt; 60022</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h5 id="1133-编写docker-composeyml"><a class="markdownIt-Anchor" href="#1133-编写docker-composeyml"></a> 11.3.3 编写docker-compose.yml</h5><blockquote><p>docker-compose.yml文件去安装gitlab（下载和运行的时间比较长的）</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr"> gitlab:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">'twang2218/gitlab-ce-zh:11.1.4'</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">"gitlab"</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  hostname:</span> <span class="string">'gitlab'</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">   TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line"><span class="attr">   GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    external_url 'http://192.168.199.110'</span></span><br><span class="line"><span class="string">    gitlab_rails['time_zone'] = 'Asia/Shanghai'</span></span><br><span class="line"><span class="string">    gitlab_rails['smtp_enable'] = true</span></span><br><span class="line"><span class="string">    gitlab_rails['gitlab_shell_ssh_port'] = 22</span></span><br><span class="line"><span class="string"></span><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'80:80'</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'443:443'</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'22:22'</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/config:/etc/gitlab</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/data:/var/opt/gitlab</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h4 id="114-搭建gitlabrunner"><a class="markdownIt-Anchor" href="#114-搭建gitlabrunner"></a> 11.4 搭建GitlabRunner</h4><h5 id="1141-配置私服信息"><a class="markdownIt-Anchor" href="#1141-配置私服信息"></a> 11.4.1 配置私服信息</h5><blockquote><p>创建或修改/etc/docker/daemon.json，并添加如下内容。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"baseservice.qfjava.cn:60001"</span> </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重启两个服务</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h5 id="1142-添加docker-composeyml文件"><a class="markdownIt-Anchor" href="#1142-添加docker-composeyml文件"></a> 11.4.2 添加docker-compose.yml文件</h5><blockquote><ul><li>创建工作目录 /opt/docker_gitlab-runner</li><li>在 /opt/docker_gitlab-runner添加docker-compose.yml文件</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  gitlab-runner:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">environment</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">gitlab-runner</span></span><br><span class="line"><span class="attr">    privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./config:/etc/gitlab-runner</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><h5 id="1143-在yml文件目录添加环境目录"><a class="markdownIt-Anchor" href="#1143-在yml文件目录添加环境目录"></a> 11.4.3 在yml文件目录添加环境目录</h5><blockquote><p>创建environment目录，在目录中逐个添加各个配置及软件</p></blockquote><blockquote><p>Dockerfile</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">FROM baseservice.qfjava.cn:60001/gitlab-runner:bleeding</span><br><span class="line"># 修改软件源</span><br><span class="line">RUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&apos; &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    #下面的地址需要根据实际情况变化</span><br><span class="line">    wget https://http.kali.org/kali/pool/main/k/kali-archive-keyring/kali-archive-keyring_2018.2_all.deb --no-check-certificate &amp;&amp; \</span><br><span class="line">    apt install -y ./kali-archive-keyring_2018.2_all.deb &amp;&amp; \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt install -y  gnupg  &amp;&amp; \</span><br><span class="line">    apt-get clean</span><br><span class="line"></span><br><span class="line"># 安装 Docker</span><br><span class="line">RUN curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - &amp;&amp; \</span><br><span class="line">    apt-get install -y python-software-properties software-properties-common &amp;&amp; \</span><br><span class="line">    echo &apos;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&apos; &gt;&gt; /etc/apt/sources.list.d/docker.list &amp;&amp; \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y docker-ce</span><br><span class="line"></span><br><span class="line">COPY daemon.json /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"># 安装 Docker Compose,因为下载不下来，所以我们本地上传一份docker-compose到environment目录</span><br><span class="line">WORKDIR /usr/local/bin</span><br><span class="line">#RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose</span><br><span class="line">COPY docker-compose docker-compose</span><br><span class="line">RUN chmod +x docker-compose</span><br><span class="line"></span><br><span class="line"># 安装 Java</span><br><span class="line">RUN mkdir -p /usr/local/java</span><br><span class="line">WORKDIR /usr/local/java</span><br><span class="line">COPY jdk-8u231-linux-x64.tar.gz /usr/local/java</span><br><span class="line">RUN tar -zxvf jdk-8u231-linux-x64.tar.gz &amp;&amp; \</span><br><span class="line">    rm -fr jdk-8u231-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># 安装 Maven</span><br><span class="line">RUN mkdir -p /usr/local/maven</span><br><span class="line">WORKDIR /usr/local/maven</span><br><span class="line"># RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">COPY apache-maven-3.6.3-bin.tar.gz /usr/local/maven</span><br><span class="line">RUN tar -zxvf apache-maven-3.6.3-bin.tar.gz &amp;&amp; \</span><br><span class="line">    rm -fr apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">#需要配置maven 私服的话,不需要就加#注释掉</span><br><span class="line">#COPY settings.xml /usr/local/maven/apache-maven-3.6.3/conf/settings.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_231</span><br><span class="line">ENV MAVEN_HOME /usr/local/maven/apache-maven-3.6.3</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /</span><br></pre></td></tr></table></figure><blockquote><p>daemon.json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;: [</span><br><span class="line">    &quot;baseservice.qfjava.cn:60001&quot; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>docker-compose可执行文件。</p></blockquote><blockquote><p><a href>apache-maven-3.6.3-bin.tar.gz</a>，以及<a href>jdk-8u231-linux-x64.tar.gz</a>压缩包文件。</p></blockquote><h5 id="1144-设置docker权限"><a class="markdownIt-Anchor" href="#1144-设置docker权限"></a> 11.4.4 设置Docker权限</h5><blockquote><ul><li>在宿主机启动docker程序后先执行 <a href>sudo chown root:root /var/run/docker.sock</a>。</li><li>在<a href>/opt/docker_gitlab-runner</a>目录中执行<a href>docker-compose up -d --build</a>启动容器。</li><li>启动容器成功后，添加容器权限，保证容器可以使用宿主机的docker：<a href>docker exec -it gitlab-runner usermod -aG root gitlab-runner</a></li></ul></blockquote><h5 id="1145-注册runner信息到gitlab"><a class="markdownIt-Anchor" href="#1145-注册runner信息到gitlab"></a> 11.4.5 注册Runner信息到gitlab</h5><blockquote><p>注册信息整个过程</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab-runner gitlab-runner register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 GitLab 地址</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):</span><br><span class="line">http://192.168.199.109/  <span class="comment"># 根据gitlab地址添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 GitLab Token</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner:</span><br><span class="line">1Lxq_f1NRfCfeNbE5WRh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 Runner 的说明</span></span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner:</span><br><span class="line">可以为空</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span></span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里选择 true ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to run untagged builds [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里选择 false，可以直接回车，默认为 false（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to lock Runner to current project [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 runner 执行器，这里我们选择的是 shell</span></span><br><span class="line">Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h4 id="115-整合项目入门测试"><a class="markdownIt-Anchor" href="#115-整合项目入门测试"></a> 11.5 整合项目入门测试</h4><h5 id="1151-创建项目"><a class="markdownIt-Anchor" href="#1151-创建项目"></a> 11.5.1 创建项目</h5><blockquote><p>创建maven工程，添加web.xml文件，编写html页面</p></blockquote><h5 id="1152-编写gitlab-ciyml"><a class="markdownIt-Anchor" href="#1152-编写gitlab-ciyml"></a> 11.5.2 编写.gitlab-ci.yml</h5><blockquote><p>编写<a href>.gitlab-ci.yml</a>文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo first test ci   # 测试回声命令，测试效果</span><br></pre></td></tr></table></figure><h5 id="1153-将maven工程推送到gitlab中"><a class="markdownIt-Anchor" href="#1153-将maven工程推送到gitlab中"></a> 11.5.3 将maven工程推送到gitlab中</h5><blockquote><p>执行git命令推送到Gitlab</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h5 id="1154-查看效果"><a class="markdownIt-Anchor" href="#1154-查看效果"></a> 11.5.4 查看效果</h5><blockquote><p>可以在gitlab中查看到gitlab-ci.yml编写的内容</p></blockquote><table><thead><tr><th style="text-align:center">效果图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588671760385.png" alt="1588671760385"></td></tr></tbody></table><h4 id="116-完善项目配置"><a class="markdownIt-Anchor" href="#116-完善项目配置"></a> 11.6 完善项目配置</h4><blockquote><p>添加Dockerfile以及docker-compose.yml， 并修改<a href>.gitlab-ci.yml</a>文件</p></blockquote><h5 id="1161-创建dockerfile"><a class="markdownIt-Anchor" href="#1161-创建dockerfile"></a> 11.6.1 创建Dockerfile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfile</span><br><span class="line">FROM daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">COPY testci.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h5 id="1162-创建docker-composeyml"><a class="markdownIt-Anchor" href="#1162-创建docker-composeyml"></a> 11.6.2 创建docker-compose.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  testci:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">testci</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h5 id="1163-修改gitlab-ciyml"><a class="markdownIt-Anchor" href="#1163-修改gitlab-ciyml"></a> 11.6.3 修改.gitlab-ci.yml</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ci.yml</span><br><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo first test ci</span><br><span class="line">    - /usr/local/maven/apache-maven-3.6.3/bin/mvn package</span><br><span class="line">    - cp target/testci-1.0-SNAPSHOT.war docker/testci.war</span><br><span class="line">    - docker-compose down</span><br><span class="line">    - docker-compose up -d --build</span><br><span class="line">    - docker rmi $(docker images -qf dangling=true)</span><br></pre></td></tr></table></figure><h5 id="1164-测试"><a class="markdownIt-Anchor" href="#1164-测试"></a> 11.6.4 测试</h5><table><thead><tr><th style="text-align:center">测试效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588674040060.png" alt="1588674040060"></td></tr></tbody></table><h4 id="117-cd介绍"><a class="markdownIt-Anchor" href="#117-cd介绍"></a> 11.7 CD介绍</h4><blockquote><p>CD（持续交付，持续部署）</p><p>持续交付：将代码交付给专业的测试团队去测试</p><p>持续部署：可以直接将指定好tag的代码直接部署到生产环境中</p></blockquote><table><thead><tr><th style="text-align:center">CICD图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588677492583.png" alt="1588677492583"></td></tr></tbody></table><h4 id="118-安装jenkins"><a class="markdownIt-Anchor" href="#118-安装jenkins"></a> 11.8 安装Jenkins</h4><h5 id="1181-编写docker-composeyml"><a class="markdownIt-Anchor" href="#1181-编写docker-composeyml"></a> 11.8.1 编写docker-compose.yml</h5><blockquote><p>官网：<a href="https://www.jenkins.io/" target="_blank" rel="noopener">https://www.jenkins.io/</a></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">jenkins/jenkins</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="number">8888</span><span class="string">:8080</span></span><br><span class="line"><span class="bullet">     -</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">./data:/var/jenkins_home</span></span><br></pre></td></tr></table></figure><h5 id="1182-运行并访问jenkins"><a class="markdownIt-Anchor" href="#1182-运行并访问jenkins"></a> 11.8.2 运行并访问Jenkins</h5><blockquote><p>第一次运行时，会因为data目录没有权限，导致启动失败</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 data</span><br></pre></td></tr></table></figure><blockquote><p>访问http://192.168.199.109:8888</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问速度奇慢无比。。。。。</span><br></pre></td></tr></table></figure><blockquote><p>访问成功后，需要输入密码，可在日志中查看</p></blockquote><table><thead><tr><th>查看日志,以及Jenkins页面</th></tr></thead><tbody><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232643961.png" alt="image-20200708232643961"></td></tr><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232614918.png" alt="image-20200708232614918"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">选择安装插件方式</th></tr></thead><tbody><tr><td style="text-align:center">手动选择插件.</td></tr></tbody></table><blockquote><p>查看需要实现安装<a href>Publish Over SSH</a> 以及 <a href>Git Parameter</a></p></blockquote><table><thead><tr><th style="text-align:center">安装插件</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232754318.png" alt="image-20200708232754318"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232800931.png" alt="image-20200708232800931"></td></tr></tbody></table><blockquote><p>安装成功后，需要指定上用户名和密码等信息</p></blockquote><table><thead><tr><th style="text-align:center">指定用户名密码信息</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232842803.png" alt="image-20200708232842803"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232910197.png" alt="image-20200708232910197"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232922638.png" alt="image-20200708232922638"></td></tr></tbody></table><blockquote><p>登陆成功</p></blockquote><table><thead><tr><th style="text-align:center">登录成功</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681196639.png" alt="1588681196639"></td></tr></tbody></table><blockquote><p>登录成功后,还需要单独安装<a href>Persistent Parameter</a>插件</p></blockquote><table><thead><tr><th style="text-align:center">安装方式及安装成功图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708233023116.png" alt="image-20200708233023116"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708233031967.png" alt="image-20200708233031967"></td></tr></tbody></table><h4 id="119-配置jenkins的目标服务器"><a class="markdownIt-Anchor" href="#119-配置jenkins的目标服务器"></a> 11.9 配置Jenkins的目标服务器</h4><blockquote><p>执行过程：代码提交到Gitlab，Jenkins会从Gitlab中拉取代码，并在Jenkins中打包并发布到目标服务器中。</p></blockquote><h5 id="1191-点击左侧的系统设置"><a class="markdownIt-Anchor" href="#1191-点击左侧的系统设置"></a> 11.9.1 点击左侧的系统设置</h5><table><thead><tr><th style="text-align:center">左侧导航</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681954779.png" alt="1588681954779"></td></tr></tbody></table><h5 id="1192-选中中间区域的系统设置"><a class="markdownIt-Anchor" href="#1192-选中中间区域的系统设置"></a> 11.9.2 选中中间区域的系统设置</h5><table><thead><tr><th style="text-align:center">系统设置</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681970621.png" alt="1588681970621"></td></tr></tbody></table><h5 id="1193-搜索publish-over-ssh"><a class="markdownIt-Anchor" href="#1193-搜索publish-over-ssh"></a> 11.9.3 搜索Publish over SSH</h5><table><thead><tr><th style="text-align:center">Publish over SSH</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588682011820.png" alt="1588682011820"></td></tr></tbody></table><h5 id="1194-点击上图新增"><a class="markdownIt-Anchor" href="#1194-点击上图新增"></a> 11.9.4 点击上图新增</h5><table><thead><tr><th>新增SSH连接</th></tr></thead><tbody><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588682092002.png" alt="1588682092002"></td></tr></tbody></table><h4 id="1110-配置gitlab免密码登录"><a class="markdownIt-Anchor" href="#1110-配置gitlab免密码登录"></a> 11.10 配置GitLab免密码登录</h4><blockquote><p>链接Gitlab需要使用密码，我们可以通过SSH的方式，免密码登陆Gitlab拉取代码，避免每次都输入密码。</p></blockquote><h5 id="11101登录jenkins容器内部"><a class="markdownIt-Anchor" href="#11101登录jenkins容器内部"></a> 11.10.1登录Jenkins容器内部</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jenkins bash</span><br></pre></td></tr></table></figure><h5 id="11102-输入生成ssh秘钥命令"><a class="markdownIt-Anchor" href="#11102-输入生成ssh秘钥命令"></a> 11.10.2 输入生成SSH秘钥命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱（随便写）&quot;</span><br></pre></td></tr></table></figure><h5 id="11103将秘钥复制到gitlab的ssh中"><a class="markdownIt-Anchor" href="#11103将秘钥复制到gitlab的ssh中"></a> 11.10.3将秘钥复制到GitLab的SSH中</h5><table><thead><tr><th style="text-align:center">配置密钥</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588683585249.png" alt="1588683585249"></td></tr></tbody></table><h4 id="1111-配置jdk和maven"><a class="markdownIt-Anchor" href="#1111-配置jdk和maven"></a> 11.11 配置JDK和Maven</h4><blockquote><p>我们需要再Jenkins中将代码打包，需要依赖JDK和Maven的环境</p></blockquote><h5 id="11111-复制软件到data目录下"><a class="markdownIt-Anchor" href="#11111-复制软件到data目录下"></a> 11.11.1 复制软件到data目录下</h5><table><thead><tr><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588684490466.png" alt="1588684490466"></td></tr></tbody></table><h5 id="11112-在监控界面中配置jdk和maven"><a class="markdownIt-Anchor" href="#11112-在监控界面中配置jdk和maven"></a> 11.11.2 在监控界面中配置JDK和Maven</h5><table><thead><tr><th style="text-align:center">配置环境变量</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588684458028.png" alt="1588684458028"></td></tr></tbody></table><h5 id="11113-手动拉取gitlab项目"><a class="markdownIt-Anchor" href="#11113-手动拉取gitlab项目"></a> 11.11.3 手动拉取gitlab项目</h5><blockquote><p>使用SSH无密码连接时，第一次连接需要手动确定</p></blockquote><table><thead><tr><th style="text-align:center">手动拉取一次</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588685220324.png" alt="1588685220324"></td></tr></tbody></table><h4 id="1112-创建maven任务"><a class="markdownIt-Anchor" href="#1112-创建maven任务"></a> 11.12 创建maven任务</h4><blockquote><p>实现通过Jenkins的Maven任务，自动去Gitlab拉取代码，并在本地打包，发布到目标服务器上</p></blockquote><h5 id="11121-创建maven工程推送到gitlab中"><a class="markdownIt-Anchor" href="#11121-创建maven工程推送到gitlab中"></a> 11.12.1 创建maven工程，推送到GitLab中</h5><blockquote><p>随便创建一个即可……</p></blockquote><h5 id="11122-jenkins的监控页面中创建maven任务"><a class="markdownIt-Anchor" href="#11122-jenkins的监控页面中创建maven任务"></a> 11.12.2 Jenkins的监控页面中创建maven任务</h5><table><thead><tr><th style="text-align:center">指定GitLab地址</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686481506.png" alt="1588686481506"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">指定maven打包方式</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686489821.png" alt="1588686489821"></td></tr></tbody></table><h5 id="11123-执行maven任务"><a class="markdownIt-Anchor" href="#11123-执行maven任务"></a> 11.12.3 执行maven任务</h5><table><thead><tr><th style="text-align:center">立即构建，并查看日志</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686591351.png" alt="1588686591351"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">控制台查看日志信息</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686553880.png" alt="1588686553880"></td></tr></tbody></table><h5 id="11124-最终效果"><a class="markdownIt-Anchor" href="#11124-最终效果"></a> 11.12.4 最终效果</h5><table><thead><tr><th style="text-align:center">打包成功</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588687382594.png" alt="1588687382594"></td></tr></tbody></table><h4 id="1113-实现持续交付持续部署"><a class="markdownIt-Anchor" href="#1113-实现持续交付持续部署"></a> 11.13 实现持续交付持续部署</h4><blockquote><p>实现根据tag标签，实现持续交付和持续部署</p></blockquote><h5 id="11131-安装persistent-parameter的插件"><a class="markdownIt-Anchor" href="#11131-安装persistent-parameter的插件"></a> 11.13.1 安装Persistent Parameter的插件</h5><table><thead><tr><th style="text-align:center">安装插件</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588693533099.png" alt="1588693533099"></td></tr></tbody></table><h5 id="11132-重新指定构建项目的方式"><a class="markdownIt-Anchor" href="#11132-重新指定构建项目的方式"></a> 11.13.2 重新指定构建项目的方式</h5><table><thead><tr><th style="text-align:center">根据标签构建项目</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588696879059.png" alt="1588696879059"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">自定义构建</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588697752850.png" alt="1588697752850"></td></tr></tbody></table><h5 id="11133-构建项目成功后需要将内容发布到目标服务器"><a class="markdownIt-Anchor" href="#11133-构建项目成功后需要将内容发布到目标服务器"></a> 11.13.3 构建项目成功后，需要将内容发布到目标服务器</h5><table><thead><tr><th style="text-align:center">发布服务器后执行的命令</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588697770621.png" alt="1588697770621"></td></tr></tbody></table><h5 id="11134-添加程序代码"><a class="markdownIt-Anchor" href="#11134-添加程序代码"></a> 11.13.4 添加程序代码</h5><blockquote><p>指定目标服务器的Dockerfile以及docker-compose.yml文件。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 文件</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">testcd-1.0-SNAPSHOT.war</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose.yml文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  testcd:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">testcd</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8081</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h5 id="11135-测试"><a class="markdownIt-Anchor" href="#11135-测试"></a> 11.13.5 测试</h5><blockquote><p>在Jenkins中指定Tag后，Jenkins会从Gitlab拉取指定版本分支，并打包推送到目标服务器。</p></blockquote><table><thead><tr><th style="text-align:center">根据标签修改发布版本</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588700462690.png" alt="1588700462690"></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --&gt;&lt;p&gt;&lt;img src=&quot;http://qgw3wcroi.hn-bkt.clouddn.com/1586333742105.png&quot; alt=&quot;15863337
      
    
    </summary>
    
      <category term="微服务" scheme="yihao.ml/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>高效VIM编辑器</title>
    <link href="yihao.ml/2020/11/15/newnote_1605333862096/"/>
    <id>yihao.ml/2020/11/15/newnote_1605333862096/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T05:36:10.082Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率</p><h2 id="vim-中自定义快捷键"><a class="markdownIt-Anchor" href="#vim-中自定义快捷键"></a> Vim 中自定义快捷键</h2><p>map系列命令<br>这个命令的声明如下: :map {lhs} {rhs}。这个命令就是将{lhs}代表的按键映射成{rhs}所代表的按键。例如map L 就是将键映射成L。此外需要注意的是map命令定义的快捷键是可以嵌套的，例如下面这样的命令:</p><p>map L $<br>map Y yL</p><p>就是将Y按键映射成了y$按键。</p><p>更多详情参考:<a href="https://www.cnblogs.com/boldness2012/p/12432792.html" target="_blank" rel="noopener">https://www.cnblogs.com/boldness2012/p/12432792.html</a></p><h2 id="vim默认设置"><a class="markdownIt-Anchor" href="#vim默认设置"></a> Vim默认设置</h2><p>在<code>.vimrc</code>文件中添加下面内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用高亮</span></span><br><span class="line">syntax <span class="built_in">enable</span>                                                                                                           </span><br><span class="line"><span class="comment"># 设置行号</span></span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="comment"># 设置卡尺</span></span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="comment"># 高亮当前行</span></span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="comment"># F4 格式化JSON内容</span></span><br><span class="line">map &lt;F4&gt; &lt;Esc&gt;:%!python -m json.tool&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>第8行是格式化json的快捷键设置，在vim模式下按F4即可格式化Json数据</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率&lt;/p&gt;&lt;h2 id=&quot;vim-中自定义快捷键&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Linux" scheme="yihao.ml/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>软链接解决磁盘不足</title>
    <link href="yihao.ml/2020/11/15/2020%E2%80%9310-05-%E8%BD%AF%E9%93%BE%E6%8E%A5%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3/"/>
    <id>yihao.ml/2020/11/15/2020–10-05-软链接解决磁盘不足/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>本人使用Linux系统作为主系统，在装系统时，分区分的有些小，导致现在装点东西都很难办。</p><h2 id="1操作系统"><a class="markdownIt-Anchor" href="#1操作系统"></a> 1.操作系统</h2><p><img src="http://qgw3wcroi.hn-bkt.clouddn.com/snapshot.png" alt="xx"></p><h2 id="2问题"><a class="markdownIt-Anchor" href="#2问题"></a> 2.问题</h2><p>因为ubuntu中安装软件，大部分都是这样<code>sudo apt-get install mysql</code> 往往我们都不自定义安装路径，这样导致我的其它磁盘空间很大，根目录空间严重不足。</p><p>网上有说清缓存、清理不用的软件、拓展系统分区，这些方案要么是不靠谱，要么是太过麻烦。</p><p>这个问题困扰我蛮久的，最近想到了一个办法，用软链接将大目录或文件链接到其它磁盘，来增加源磁盘空间。</p><p>操作很简单，大致思路如下</p><pre><code>* 复制srcPath到targetPath （复制的时候要加 -a 参数复制源目录的权限、组等信息）* 备份srcPath （保证万无一失）* 建立targetPath 软链接</code></pre><h2 id="3解决"><a class="markdownIt-Anchor" href="#3解决"></a> 3.解决</h2><p>为了方便管理，在挂载的<code>/ssd</code>下面创建<strong>root</strong>目录，以后<code>/ssd/root</code>将作为target目录做统一处理。</p><p>下面写了一个简单的shell，方便操作，使用办法<code>sh lnTool.sh -src=/usr/lib/xxx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sh lnTool.sh -src=/usr/lib/xxx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移动src到target并创建软链接,解决目前空间不足问题</span></span><br><span class="line"></span><br><span class="line">opts=$@</span><br><span class="line">getparam()&#123;</span><br><span class="line">arg=$1</span><br><span class="line">echo $opts | xargs -n1 | cut -b 2- | awk -F"=" '&#123;if($1=="'"$arg"'") print $2&#125;'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">src=$(getparam src)</span><br><span class="line">target=/ssd/root$src</span><br><span class="line"><span class="meta">#</span><span class="bash"> crete target dir</span></span><br><span class="line">sudo mkdir -p $target</span><br><span class="line"><span class="meta">#</span><span class="bash"> copy src to target</span></span><br><span class="line">sudo cp -a $src/* $target</span><br><span class="line"><span class="meta">#</span><span class="bash"> back src</span></span><br><span class="line">sudo mv $src $src.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> create soft link</span></span><br><span class="line">sudo ln -s $target $src</span><br></pre></td></tr></table></figure><p>比如,发现<code>/usr/share/doc</code>目录很大，使用shell完成建立软链接</p><p>直接运行 <code>sh lnTool.sh -src=/usr/share/doc</code>即可。</p><p>如果使用提供的<strong>shell</strong>的话，先<font color="red">做适当改动并拿几个文件试一下，以免出现问题。</font></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;本人使用Linux系统作为主系统，在装系统时，分区分的有些小，导致现在装点东西都很难办。&lt;/p&gt;&lt;h2 id=&quot;1操作系统&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Linux" scheme="yihao.ml/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="yihao.ml/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Docker修改镜像存储位置</title>
    <link href="yihao.ml/2020/11/15/2020%E2%80%9309-22-docker%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8/"/>
    <id>yihao.ml/2020/11/15/2020–09-22-docker修改镜像存储/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>早期安装ubuntu+win双系统给ubuntu划分存储过小，导致现在不够用，使用下面配置修改Docker镜像存储目录。</p><p>Docker 默认镜像存储路径为 <code>/var/lib/docker</code>，下面修改位置并重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;],</span><br><span class="line">        &quot;graph&quot;: &quot;/media/zyh/SSD/root/var/lib/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改服务后发现拉完镜像无法启动，原因是<code>/media/zyh/SSD</code>这个磁盘格式是<code>HPFS/NTFS/exFAT</code></p><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案：</h3><p>将磁盘<code>/media/zyh/SSD</code>格式化为<code>ext4</code>格式，并挂载到<code>/</code>目录下即可</p><p>具体格式化磁盘的方法可以参考blog:<a href="https://www.cnblogs.com/bpdhpm/p/11384473.html" target="_blank" rel="noopener">https://www.cnblogs.com/bpdhpm/p/11384473.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;早期安装ubuntu+win双系统给ubuntu划分存储过小，导致现在不够用，使用下面配置修改Docker镜像存储目录。&lt;/p&gt;&lt;p&gt;Docker 默认镜像
      
    
    </summary>
    
      <category term="微服务" scheme="yihao.ml/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="问题总结" scheme="yihao.ml/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Wow 插件开发-清理背包插件</title>
    <link href="yihao.ml/2020/11/15/2020%E2%80%9307-24-Wow%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>yihao.ml/2020/11/15/2020–07-24-Wow 插件开发/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.602Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p><video src="http://qgw3wcroi.hn-bkt.clouddn.com/7mQ5-4zp4XoZ6kT3cSku-ig.gif.mp4" controls></video></p><p>在对话框中输入 “/delete [轻弹丸]” 回车即可删除轻弹丸,有了这个就可以方便的删除掉背包的任意垃圾</p><h3 id="1安装ide"><a class="markdownIt-Anchor" href="#1安装ide"></a> 1.安装IDE</h3><p>编辑器这里我推荐用sublime，因为它可以装格式化lua 代码插件，而且高亮显示关键字。如果你喜欢用Notepad++,Vscode，Editplus也无所谓，选择一个自己喜欢的。</p><p>Sublime3 [<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a>]</p><h3 id="2编写plugin"><a class="markdownIt-Anchor" href="#2编写plugin"></a> 2.编写Plugin</h3><p>打开Sublime 3</p><p>执行：File -&gt; Open Folder ，选择WOW插件目录\World of Warcraft_classic_\Interface\AddOns</p><p>打开目录以后,创建一个MyDelete的目录，并在目录下创建两个文件MyDelete.toc和MyDelete.lua。</p><p>下面我们开始写代码,用的语言是Lua</p><p>第一个MyDelete.toc中包含了我们的插件描述信息，其中包含标题、作者、版本号、备注、lua脚本连接等，具体代码如下：</p><p>MyDelete.toc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## Interface: 32999</span><br><span class="line">## Title: MyDelete</span><br><span class="line">## Author: zyh</span><br><span class="line">## Version: 0.1</span><br><span class="line">## Notes: 自动清理背包</span><br><span class="line">## DefaultState: Enabled</span><br><span class="line">## LoadOnDemand: 0</span><br><span class="line">## SavedVariables:</span><br><span class="line">MyDelete.lua</span><br></pre></td></tr></table></figure><p>第二个MyDelete.lua 中包含了我们的核心代码部分，核心思想如下:</p><ul><li>Drop函数，注册/delete 指令</li><li>DeleteItemAction函数，是/delete 指令触发的函数，其核心思路是：遍历背包中的所有solt(槽)，匹配待删除物品，检测到物品以后使用PickupContainerItem和DeleteCursorItem两个API来丢弃物品</li><li>GetItemName函数，获取 Item Hyperlink (物品超链接)中的Item Name (物品名称)，这边Item Name和Item Hyperlink是两个概念。</li></ul><p>MyDelete.lua</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Drop()</span><br><span class="line"></span><br><span class="line">    SlashCmdList[&quot;DeleteItem&quot;] = DeleteItemAction</span><br><span class="line">    SLASH_DeleteItem1 = &quot;/delete&quot;</span><br><span class="line">    print(&quot;MyDelete load finish&quot;)</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function GetItemName(item)</span><br><span class="line"></span><br><span class="line">    itemName, itemLink, itemRarity, itemLevel, itemMinLevel, itemType, itemSubType, itemStackCount, itemEquipLoc, itemIcon, </span><br><span class="line">    itemSellPrice, itemClassID, itemSubClassID, bindType, expacID, itemSetID, isCraftingReagent = GetItemInfo(item)</span><br><span class="line">    </span><br><span class="line">    return itemName</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function DeleteItemAction(item)</span><br><span class="line">    if item == &quot;&quot; then return end</span><br><span class="line"></span><br><span class="line">    name = GetItemName(item)</span><br><span class="line">    for b = 0, 4 do</span><br><span class="line">        p = GetContainerNumSlots(b)</span><br><span class="line">        for i = 1, p do</span><br><span class="line">            e = GetContainerItemLink(b, i)</span><br><span class="line">            if e and string.find(e, name) then</span><br><span class="line">                PickupContainerItem(b, i);</span><br><span class="line">                DeleteCursorItem();</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local frame = CreateFrame(&quot;Frame&quot;, nil, UIParent);</span><br><span class="line">frame:RegisterEvent(&quot;VARIABLES_LOADED&quot;);</span><br><span class="line">frame:SetScript(&quot;OnEvent&quot;, Drop);</span><br></pre></td></tr></table></figure><p>将两个核心文件放到AddOns/MyDelete目录下，重启WOW。进入游戏以后，先看一下“综合”频道有没有打出“MyDelete load finish”等字样，如果有，则插件已经生效。</p><p>如果你是粘贴的我的代码，你应该已经看到了“MyDelete load finish”</p><h3 id="3测试"><a class="markdownIt-Anchor" href="#3测试"></a> 3.测试</h3><p>下面我们来删除一些东西测试一下，<font color="red">请在操作之前务必用自己的小号或者腾空自己的背包</font>，不然删掉一些重要物品就玩大了。</p><p>到商店卖一些轻弹丸和重弹丸，或者找点便宜的道具。 输入<code>/delete</code> 在后面跟上轻弹丸的超链接(shift + 鼠标左键)，然后回车查看效果</p><h3 id="4其他"><a class="markdownIt-Anchor" href="#4其他"></a> 4.其他</h3><p>下面附上wow api地址，想了解的看一下<br>:[<a href="http://wowprogramming.com/docs/api.html" target="_blank" rel="noopener">http://wowprogramming.com/docs/api.html</a>]</p><p>想给Sublime安装格式化LUA代码工具，连接地址:[<a href="https://github.com/Koihik/LuaFormatter" target="_blank" rel="noopener">https://github.com/Koihik/LuaFormatter</a>]</p><p>有朋友跟我反应不想用超链接删除物品，喜欢打字，其实也好改，只需要该DeleteItemAction函数即可，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function DeleteItemAction(item)</span><br><span class="line"></span><br><span class="line">    if item == &quot;&quot; then return end</span><br><span class="line"></span><br><span class="line">    --name = GetItemName(item)</span><br><span class="line">    for b = 0, 4 do</span><br><span class="line">        p = GetContainerNumSlots(b)</span><br><span class="line">        for i = 1, p do</span><br><span class="line">            e = GetContainerItemLink(b, i)</span><br><span class="line">            if e and string.find(e, item ) then</span><br><span class="line">                PickupContainerItem(b, i);</span><br><span class="line">                DeleteCursorItem();</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样改好以后输入/rl 重新加载，输入 &quot;/delete 轻弹丸 &quot;查看效果</p><p>Tips：可以结合宏一起使用比如我这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/delete 加固的宝箱</span><br><span class="line">/delete 新鲜的大鱼</span><br><span class="line">/delete 巨型蚌壳</span><br><span class="line">/delete 21磅重的龙虾</span><br><span class="line">/delete 12磅重的龙虾</span><br><span class="line">/delete 9磅重的龙虾</span><br><span class="line">/delete 7磅重的龙虾</span><br></pre></td></tr></table></figure><p><a href="https://bbs.nga.cn/read.php?&amp;tid=22813671" target="_blank" rel="noopener">https://bbs.nga.cn/read.php?&amp;tid=22813671</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;&lt;video src=&quot;http://qgw3wcroi.hn-bkt.clouddn.com/7mQ5-4zp4XoZ6kT3cSku-ig.gif.mp
      
    
    </summary>
    
      <category term="游戏开发" scheme="yihao.ml/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Wow" scheme="yihao.ml/tags/Wow/"/>
    
  </entry>
  
  <entry>
    <title>K近邻算法-KNN</title>
    <link href="yihao.ml/2020/11/15/2020-02-18-k%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>yihao.ml/2020/11/15/2020-02-18-k最近邻算法/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.602Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>KNN是监督学习中解决分类问题的一种算法，又叫 K-Nearest Neighbor。</p><p>它的一个基本思路是：如果一个样本在特征空间中，K个最近邻的样本中的大多数属于某一类型，那么这个样本也划分为这个类型。我们可以结合下图（图源自WIKI）。来进一步了解一下它是如何对样本点进行分类的。</p><p><img src="https://i.loli.net/2020/02/18/b1tvMYDg9p6INJO.png" alt="330px-KnnClassification.svg.png"></p><p>在图示中有两种点，一种蓝色正方形，一种红色三角形，那么现在请问绿色的圆形点会被分到哪一类？</p><p>情况一： 假定，找3个(K)离圆点最近的点。是蓝色正方形的概率为1/3；是红色三角形的概率为2/3。那么该点就是红色三角形这一类。</p><p>情况二： 假定，找5个(K)离圆点最近的点。是蓝色正方形的概率为3/5；是红色三角形的概率为2/5，那么该点就是蓝色正方形这一类。</p><p>由此可见，KNN算法中的K对结果的影响还是蛮大的，因此在训练模型阶段要选取一个合适的K值。</p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>1）计算测试数据和个样本数据之间的距离<br>2）按照距离的递增关系排序<br>3）选择距离最小的K个点<br>4）确定前K个点所在类别的出现频率<br>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类</p><h4 id="代码实现步骤"><a class="markdownIt-Anchor" href="#代码实现步骤"></a> 代码实现步骤</h4><h5 id="0引入依赖"><a class="markdownIt-Anchor" href="#0引入依赖"></a> 0.引入依赖</h5><p>这里引入sklearn里的数据集iris，其中有iris.data（150个样本),iris.target（每个样本的分类）</p><p>这里引入skelearn里的train_test_split将iris数据 切分数据集为<code>训练集</code>和<code>测试集</code></p><p>为了判断最终预测结果的好坏，我们使用了sklearn里的accuracy_score函数，它可以方便的计算准确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br></pre></td></tr></table></figure><h5 id="1-数据加载和预处理"><a class="markdownIt-Anchor" href="#1-数据加载和预处理"></a> 1. 数据加载和预处理</h5><p>加载数据集iris，使用pandas中的DataFrame绘制出表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data = iris.data, columns = iris.feature_names)</span><br><span class="line">df[<span class="string">'class'</span>] = iris.target</span><br><span class="line">df[<span class="string">'class'</span>] = df[<span class="string">'class'</span>].map(&#123;<span class="number">0</span>: iris.target_names[<span class="number">0</span>], <span class="number">1</span>: iris.target_names[<span class="number">1</span>], <span class="number">2</span>: iris.target_names[<span class="number">2</span>]&#125;)</span><br><span class="line">df.head(<span class="number">10</span>)</span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure><p>下面划分<code>训练集</code>和<code>测试集</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x为样本点</span></span><br><span class="line">x = iris.data</span><br><span class="line"><span class="comment"># y为预测分类</span></span><br><span class="line">y = iris.target.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">35</span>, stratify=y)</span><br><span class="line"></span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br></pre></td></tr></table></figure><h5 id="2-核心算法实现"><a class="markdownIt-Anchor" href="#2-核心算法实现"></a> 2. 核心算法实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l1_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(np.abs(a-b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 欧几里得距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt( np.sum((a-b) ** <span class="number">2</span>, axis=<span class="number">1</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类器实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">kNN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个初始化方法，__init__ 是类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_neighbors = <span class="number">1</span>, dist_func = l1_distance)</span>:</span></span><br><span class="line">        self.n_neighbors = n_neighbors</span><br><span class="line">        self.dist_func = dist_func</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x_train = x</span><br><span class="line">        self.y_train = y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模型预测方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化预测分类数组</span></span><br><span class="line">        y_pred = np.zeros( (x.shape[<span class="number">0</span>], <span class="number">1</span>), dtype=self.y_train.dtype )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历输入的x数据点，取出每一个数据点的序号i和数据x_test</span></span><br><span class="line">        <span class="keyword">for</span> i, x_test <span class="keyword">in</span> enumerate(x):</span><br><span class="line">            <span class="comment"># x_test跟所有训练数据计算距离</span></span><br><span class="line">            distances = self.dist_func(self.x_train, x_test)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 得到的距离按照由近到远排序，取出索引值</span></span><br><span class="line">            nn_index = np.argsort(distances)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选取最近的k个点，保存它们对应的分类类别</span></span><br><span class="line">            nn_y = self.y_train[ nn_index[:self.n_neighbors] ].ravel()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 统计类别中出现频率最高的那个，赋给y_pred[i]</span></span><br><span class="line">            y_pred[i] = np.argmax( np.bincount(nn_y) )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><h5 id="3-测试"><a class="markdownIt-Anchor" href="#3-测试"></a> 3. 测试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个knn实例</span></span><br><span class="line">knn = kNN()</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果list</span></span><br><span class="line">result_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对不同的参数选取，做预测</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">    knn.dist_func = l1_distance <span class="keyword">if</span> p == <span class="number">1</span> <span class="keyword">else</span> l2_distance</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 考虑不同的k取值，步长为2</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">        knn.n_neighbors = k</span><br><span class="line">        <span class="comment"># 传入测试数据，做预测</span></span><br><span class="line">        y_pred = knn.predict(x_test)</span><br><span class="line">        <span class="comment"># 求出预测准确率</span></span><br><span class="line">        accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">        result_list.append([k, <span class="string">'l1_distance'</span> <span class="keyword">if</span> p == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'l2_distance'</span>, accuracy])</span><br><span class="line">df = pd.DataFrame(result_list, columns=[<span class="string">'k'</span>, <span class="string">'距离函数'</span>, <span class="string">'预测准确率'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>最终结果如下图所示：</p><p><img src="https://i.loli.net/2020/02/18/DUvoZNPylTkWz9H.png" alt="result.png"></p><p>选择欧几里得距离 K=5,7,9和选择曼哈顿距离 k=5 取得的效果最好！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;KNN是监督学习中解决分类问题的一种算法，又叫 K-Nearest Neighbor。&lt;/p&gt;&lt;p&gt;它的一个基本思路是：如果一个样本在特征空间中，K个最近邻
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>NIO聊天室</title>
    <link href="yihao.ml/2020/11/15/2020%E2%80%9309-24-NIO%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>yihao.ml/2020/11/15/2020–09-24-NIO聊天室/</id>
    <published>2020-11-15T05:02:46.109Z</published>
    <updated>2020-11-15T10:13:04.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>BIO(Blocking I/0) 为阻塞IO，NIO(Non-Blocking I/O)为非阻塞IO。</p><p>不推荐以BIO构建生产应用，它有以下特点</p><ol><li>阻塞式I/O</li><li>弹性伸缩能力差</li><li>多线程耗资源</li></ol><p>针对以上问题，NIO可以完美解决，下面为学习NIO，使用Java 原生API编写NIO聊天室，上生产的话参考封装NIO的Netty框架。</p><p>NioServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ml.yihao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java NIO编写聊天程序</span></span><br><span class="line"><span class="comment"> * 服务端程序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 20-9-24 下午11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer port = <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 构造注册中心selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建ServerSocketChannel 并绑定IP 和Port 设置为非阻塞模式</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(hostname, port));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用selector 的select方法检测就绪状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(select == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 拿到就绪集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 6. 根据channel类型处理业务逻辑</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 监听</span></span><br><span class="line">                    acceptHandler(serverSocketChannel, selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    readHandler(selectionKey , selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当监听到accept事件时，需要将socket注册到selector上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClosedChannelException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不设置这个东西会怎么样?</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        socketChannel.write(Charset.forName(ENCODING_UTF8).encode(<span class="string">"欢迎来到zyh搭建的聊天室！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听到读的事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel)selectionKey.channel();</span><br><span class="line">        <span class="comment">//socketChannel.read()</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(socketChannel.read(byteBuffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            result += Charset.forName(ENCODING_UTF8).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 广播数据</span></span><br><span class="line">            <span class="comment">//System.out.println(":: 读取的数据为" + result);</span></span><br><span class="line">            broadcast(selector, socketChannel, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 处理业务 是业务而定是否需要再次注册channel</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播数据给所有连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(Selector selector,SocketChannel sourceChannel, String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.keys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            SelectionKey selectionKey = iterator.next();</span><br><span class="line">            Channel targetChannel =  selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果targetChannel 是SocketChannel类型</span></span><br><span class="line">            <span class="comment">// 如果targetChannel 不是发消息的Channel</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel</span><br><span class="line">                        &amp;&amp; targetChannel != sourceChannel)&#123;</span><br><span class="line"></span><br><span class="line">                ((SocketChannel)targetChannel).write(Charset.forName(ENCODING_UTF8).encode(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NioServer server = <span class="keyword">new</span> NioServer();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ml.yihao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java NIO编写聊天程序</span></span><br><span class="line"><span class="comment"> * 客户端端程序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 20-9-25 上午0:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer port = <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链接服务端</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.</span><br><span class="line">                open(<span class="keyword">new</span> InetSocketAddress(hostname, port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独开个线程接收服务端给的信息</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NioClient.ReadThread(selector)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务端写数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">            String line = scanner.next();</span><br><span class="line">            socketChannel.write(Charset.forName(ENCODING_UTF8).encode(line));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioClient nioClient = <span class="keyword">new</span> NioClient();</span><br><span class="line">        nioClient.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端读数据的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadThread</span><span class="params">(Selector selector)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 监测 注册中心channel就绪状态</span></span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(select == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 拿到selectionKey集合</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历判断channel类型</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 读取客户端中的数据</span></span><br><span class="line">                            readHanler(selectionKey, selector);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 不移除会导致set 中的对象堆积</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读取数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHanler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            String message = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(socketChannel.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                buffer.flip();</span><br><span class="line"></span><br><span class="line">                message += Charset.forName(ENCODING_UTF8).decode(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(message) &amp;&amp; message.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新注册Channel到selector上</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;BIO(Blocking I/0) 为阻塞IO，NIO(Non-Blocking I/O)为非阻塞IO。&lt;/p&gt;&lt;p&gt;不推荐以BIO构建生产应用，它有以下特
      
    
    </summary>
    
      <category term="后端" scheme="yihao.ml/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="NIO" scheme="yihao.ml/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>线性回归(最小二乘法)</title>
    <link href="yihao.ml/2020/02/10/2020-02-08-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)/"/>
    <id>yihao.ml/2020/02/10/2020-02-08-线性回归(最小二乘法)/</id>
    <published>2020-02-10T10:03:27.966Z</published>
    <updated>2020-11-15T10:13:04.602Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>前面介绍过线性回归，并使用了R语言实现了训练模型，完成了通过水的沸点来估计海拔高度的预测。<a href="http://yihao.ml/2018/10/07/2018-10-07-%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/">链接</a></p><p>R语言封装了最小二乘法的具体实现。我们在调用时对其内部细节感触并不是很深，下面使用python实现 最小二乘法，加深对模型训练的理解。</p><p>0.导入数据</p><p>我们还是用前面准备好的数据,保存成a.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">194.5,131.79</span><br><span class="line">194.3,131.79</span><br><span class="line">197.9,135.02</span><br><span class="line">198.4,135.55</span><br><span class="line">199.4,136.46</span><br><span class="line">199.9,136.83</span><br><span class="line">200.9,137.82</span><br><span class="line">201.1,138.00</span><br><span class="line">201.4,138.06</span><br><span class="line">201.3,138.05</span><br><span class="line">203.6,140.04</span><br><span class="line">204.6,142.44</span><br><span class="line">209.5,145.47</span><br><span class="line">208.6,144.34</span><br><span class="line">210.7,146.30</span><br><span class="line">211.9,147.54</span><br><span class="line">212.2,147.80</span><br></pre></td></tr></table></figure><p>编写python的<code>numpy</code>和<code>matplotlib.pyplot</code>，读取a.csv并且画出所有点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="string">'/tmp/a.csv'</span></span><br><span class="line">array = np.genfromtxt(f,delimiter=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line">x = array[:,<span class="number">0</span>]</span><br><span class="line">y = array[:,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,c=<span class="string">'r'</span>)</span><br><span class="line">plt.show</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/08/bGNWdanpXxow5Rl.png" alt="1.png"></p><p>1.实现算法</p><p>下面定义一个fit方法，实现模型训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设函数为y=ax+b 求出a,b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(x,y)</span>:</span></span><br><span class="line">  sum_xy = <span class="number">0</span></span><br><span class="line">  sum_x = <span class="number">0</span></span><br><span class="line">  sum_y = <span class="number">0</span></span><br><span class="line">  sum_x2 = <span class="number">0</span></span><br><span class="line">  n = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    sum_xy += x[i]*y[i]</span><br><span class="line">    sum_x += x[i]</span><br><span class="line">    sum_y += y[i]</span><br><span class="line">    sum_x2 += x[i] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  a = ((sum_xy/n) - (sum_x/n) * (sum_y/n)) / ((sum_x2/n) - (sum_x/n) * (sum_x/n))</span><br><span class="line">  b = (sum_y/n) - (a * (sum_x/n))</span><br><span class="line">  <span class="keyword">return</span> a,b</span><br></pre></td></tr></table></figure><p>为了方便看误差，我们定义计算损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(a,b,points)</span>:</span></span><br><span class="line">  x = points[:,<span class="number">0</span>]</span><br><span class="line">  y = points[:,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  pred_y = a * x + b</span><br><span class="line">  n = y.shape[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    total += math.fabs(y[i] - pred_y[i])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><p>2.测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用fit方法完成模型训练</span></span><br><span class="line">a,b = fit(x,y)</span><br><span class="line"><span class="comment"># 计算模型 误差</span></span><br><span class="line">cost = compute(a,b,array)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"a is: "</span>, a)</span><br><span class="line">print(<span class="string">"b is: "</span>, b)</span><br><span class="line">print(<span class="string">"cost is: "</span>, cost)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画散点图</span></span><br><span class="line">plt.scatter(x,y,c=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对指定的x画出预测的Y，画直线</span></span><br><span class="line">pred_y = a * x + b</span><br><span class="line">plt.plot(x,pred_y,c=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/08/cM7DljBuhHJVo8z.png" alt="2.png"></p><p>我们发现算出来的斜率是0.8954625247967952,截距是-42.130870767876615</p><p>与R已封装的包，算得的结果很接近，这也证明了写的代码没啥问题！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;前面介绍过线性回归，并使用了R语言实现了训练模型，完成了通过水的沸点来估计海拔高度的预测。&lt;a href=&quot;http://yihao.ml/2018/10/
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>K均值聚类算法</title>
    <link href="yihao.ml/2020/02/08/2020%E2%80%9302-06-K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/"/>
    <id>yihao.ml/2020/02/08/2020–02-06-K均值聚类/</id>
    <published>2020-02-08T13:29:16.754Z</published>
    <updated>2020-11-15T10:13:04.602Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>机器学习三大类，监督学习、无监督学习和强化学习。K均值(K-Means)是无监督学习中的一种聚类算法，能有有效的将数据划分子类。</p><p><img src="https://i.loli.net/2020/02/06/pYcgJ8LtbiWRCBk.gif" alt="K-means_convergence.gif"></p><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h4><p>打开新浪新闻首页，可以发现“要闻”一栏展示了目前最热门的一组新闻。类似的还有google news等</p><p><img src="https://i.loli.net/2020/02/06/dbgT9k2hpSnvHY5.png" alt="xlxw.png"></p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>以二维数据为例，描述一下k-means的实现思路：</p><pre><code>1. 在二维平面区域内n个样本点中，首先任意选取m个点，称其为质心点2. 对n个样本点和m个质心点求距离（欧式距离），找到每个样本点离得最近的质心点3. 更新m个质心点的位置，重复第2步</code></pre><p>以下图为例，描述详细的划分流程</p><p><img src="https://i.loli.net/2020/02/06/NRheVH1ZnaBLw4A.png" alt="6step.png"></p><pre><code>1. 在平面内n个样本点中，选2个质心点标记好x，对应b)2. 分别对n个样本点和2个质心点求距离，找到每个样本点离得最近的质心点;对应图c)  3. 更新2个质心点的位置对应图d)4. 重复第2步，找到每个样本点离得最近的质心点;对应图e)5. 重复第2步，找到每个样本点离得最近的质心点;对应图f)</code></pre><p>下面使用Python语言实现模型训练和预测，其中会使用到 <code>numpy</code>、<code>matplotlib.pyplot</code>、<code>sklearn.datasets</code>、<code>scipy.spatial.distance</code>，不熟悉的童鞋自行先去补一下，看起来事半功倍！</p><h5 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h5><p>思路：使用<code>sklearn.datasets</code>提供的数据来训练出模型。然后使用训练出的模型进行预测并验证模型的正确性！</p><p>引入依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br></pre></td></tr></table></figure><p>初始化数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 是n个样本点</span></span><br><span class="line"><span class="comment"># y 是每个样本点对应的质心点</span></span><br><span class="line">x, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">6</span>, random_state=<span class="number">1234</span>, cluster_std=<span class="number">0.6</span>)</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line"><span class="comment">#print(y)</span></span><br></pre></td></tr></table></figure><p>为了方便观察，我们画出图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>], c=y)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/06/WlrCbpR1dzGgwLF.png" alt="csh.png"></p><p>编写核心k-means代码，封装一个类K_Means</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K_Means</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，参数n_clusters(k), 迭代次数max_iter ,初始质心 centroids</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n_cluster=<span class="number">6</span>,n_iters=<span class="number">300</span>,centeroids=[])</span>:</span></span><br><span class="line">self.n_cluster = n_cluster</span><br><span class="line">self.n_iters = n_iters</span><br><span class="line">self.centeroids = centeroids</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self,data)</span>:</span></span><br><span class="line"><span class="comment"># 1. 计算每个样本点和样每个质心点欧式距离</span></span><br><span class="line">distances = cdist(data,self.centeroids)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将distances排序，找到最小的那个距离的下标</span></span><br><span class="line">c_ind = np.argmin(distances,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 对每一类数据进行均值计算，更新质心点位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> self.n_cluster:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> c_ind:</span><br><span class="line">self.centeroids[i] = np.mean(data[ c_ind == i ],axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,samples)</span>:</span></span><br><span class="line">distances = cdist(samples,self.centeroids)</span><br><span class="line"><span class="keyword">return</span> np.argmin(distances,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>测试,为了方便观察我们先封装一个画子图方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画子图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotKMeans</span><span class="params">(x,y,centroids,subplot,title)</span>:</span></span><br><span class="line">  <span class="comment"># 分配子图 121表示1行2列的子图中的第一个</span></span><br><span class="line">  plt.subplot(subplot)</span><br><span class="line">  plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>],c=<span class="string">'r'</span>)</span><br><span class="line">  <span class="comment"># 画出质心点</span></span><br><span class="line">  plt.scatter(centroids[:,<span class="number">0</span>],centroids[:,<span class="number">1</span>],c=np.array(range(<span class="number">6</span>)),s=<span class="number">100</span>)</span><br><span class="line">  plt.title(title)</span><br><span class="line"></span><br><span class="line">kmeans = K_Means(max_iter=<span class="number">300</span>,centroids=np.array([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">6</span>))</span><br><span class="line">plotKMeans(x,y,kmeans.centroids,<span class="number">121</span>,<span class="string">'Init State'</span>)</span><br><span class="line"><span class="comment"># 开始聚类</span></span><br><span class="line">kmeans.fit(x)</span><br><span class="line">plotKMeans(x,y,kmeans.centroids,<span class="number">122</span>,<span class="string">'Final State'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测新数据[0,0]和[10,7]的类别</span></span><br><span class="line">x_new = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">10</span>,<span class="number">7</span>]])</span><br><span class="line">y_pred = kmeans.predict(x_new)</span><br><span class="line"><span class="comment"># 打印预测出的类别</span></span><br><span class="line">print(y_pred)</span><br><span class="line"><span class="comment"># 质心点在二维坐标轴的位置</span></span><br><span class="line">print(kmeans.centroids)</span><br><span class="line"></span><br><span class="line">plt.scatter(x_new[:,<span class="number">0</span>],x_new[:,<span class="number">1</span>],s=<span class="number">100</span>,c=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/06/qyoJAdVfBbZxpeS.png" alt="end.png"></p><p>预测的结果是[0,0]属于1; [10,7]属于5，1对应的群组是质心点[-2,0]所在的群组，而5对应的群组是质心点[9,7]所在的群组，显然是正确的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;机器学习三大类，监督学习、无监督学习和强化学习。K均值(K-Means)是无监督学习中的一种聚类算法，能有有效的将数据划分子类。&lt;/p&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="k-means" scheme="yihao.ml/tags/k-means/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组</title>
    <link href="yihao.ml/2019/12/15/2019%E2%80%9312-15-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
    <id>yihao.ml/2019/12/15/2019–12-15-稀疏数组/</id>
    <published>2019-12-15T10:06:38.644Z</published>
    <updated>2020-11-15T10:13:04.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>围棋或者五子棋程序中，存盘的操作必不可少。将整个棋盘存储下来会造成空间浪费，如果你遇到了类似问腿，可以使用一种数据结构-稀疏数组来解决此问题！</p><p>假如我们认为没放子的地方为0，黑子为1，蓝子为2，就有下面的映射关系。</p><p><img src="https://i.loli.net/2019/12/15/BdPhT31Ffsc8M6H.jpg" alt="519BAC54-3A92-4745-936C-3C923FDF10B9.jpeg"></p><p>因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据。</p><p>稀疏数组的处理方法是:</p><ul><li><ol><li>记录数组一共有几行几列，有多少个不同的值</li></ol></li><li><ol start="2"><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol></li></ul><p><img src="https://i.loli.net/2019/12/15/P76Jj1YKzWiUvoB.jpg" alt="E68E4440-A3A8-4183-B03B-428E73BDC0DD.jpeg"></p><p>代码实：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11 </span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line"><span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>]; </span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>; </span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>; </span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~~"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123; </span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非 0 数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123; </span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123; </span><br><span class="line">sum++; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>]; </span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>; </span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>; </span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"><span class="comment">// 遍历二维数组，将非 0 的值存放到sparseArr 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//count 用于记录是第几个非 0 数据 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123; </span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123; </span><br><span class="line">count++; </span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i; </span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j; </span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j]; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println(); </span><br><span class="line">System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123; </span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//将稀疏数组 --》 恢复成 原始的二维数</span></span><br><span class="line"><span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]]; </span><br><span class="line"><span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123; </span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println(); </span><br><span class="line">System.out.println(<span class="string">"恢复后的二维数组"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123; </span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data); </span><br><span class="line">&#125;</span><br><span class="line">System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;围棋或者五子棋程序中，存盘的操作必不可少。将整个棋盘存储下来会造成空间浪费，如果你遇到了类似问腿，可以使用一种数据结构-稀疏数组来解决此问题！&lt;/p&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>迷宫问题</title>
    <link href="yihao.ml/2019/12/15/2019%E2%80%9312-15-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
    <id>yihao.ml/2019/12/15/2019–12-15-迷宫问题/</id>
    <published>2019-12-15T10:06:38.644Z</published>
    <updated>2020-11-15T10:13:04.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>迷宫找路径问题被广泛应用到生活中。比如游戏，玩过LOL的会发现右下角的地图，其实它就是一个典型的找路径问题。</p><p><img src="https://i.loli.net/2019/12/15/qQW7wMRGbjlSnU6.jpg" alt="11074FCB-CF33-4522-AC7C-42C63236C275.jpeg"></p><p>下面用递归+回溯来说一下，如何找到这条路径。</p><h4 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h4><p>需求如下图所示，有一个9x9的迷宫，从入口走到出口，如何确定一个有效路径？</p><p><img src="https://i.loli.net/2019/12/15/ROvjUFsabg4dilt.jpg" alt="9D0658E0-9AD5-4C54-8634-1196CF9F2610.jpeg"></p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>1.利用二维数组建立好地图的映射，问题就变成了，从[1，1]走到[8，8]</p><p>2.假定：0没走过 1墙 2可以走 3走不通</p><p>3.走路遵循 下-&gt;右-&gt;上-&gt;左，即先走下，下走不通走右，右走不通走上，上走不通走左</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maze</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> HIGH_MAX=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> WIDTH_MAX=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[HIGH_MAX][WIDTH_MAX]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有的墙</span></span><br><span class="line">init(map);</span><br><span class="line">print(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">setWay(map, <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">print(map);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 1 表示墙</span></span><br><span class="line"><span class="comment">// 上下全部置为 1 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HIGH_MAX; i++) &#123; </span><br><span class="line">map[<span class="number">0</span>][i] = <span class="number">1</span>; </span><br><span class="line">map[<span class="number">9</span>][i] = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 左右全部置为 1 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WIDTH_MAX; i++) &#123; </span><br><span class="line">map[i][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">map[i][<span class="number">9</span>] = <span class="number">1</span>; </span><br><span class="line">&#125; <span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">map[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>; </span><br><span class="line">map[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">6</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">8</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line"><span class="comment">// 输出地图</span></span><br><span class="line">System.out.println(<span class="string">"地图的情况"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WIDTH_MAX; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; HIGH_MAX; j++) &#123; </span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125; </span><br><span class="line">System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. map 表示地图</span></span><br><span class="line"><span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1) </span></span><br><span class="line"><span class="comment">//3. 如果小球能到 map[WIDTH_MAX-2][HIGH_MAX-2] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">//4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> i 从哪个位置开始找</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> j </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果找到通路，就返回 true, 否则返回 false </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span>(map[WIDTH_MAX-<span class="number">2</span>][HIGH_MAX-<span class="number">2</span>] == <span class="number">2</span>) &#123; </span><br><span class="line"><span class="comment">// 通路已经找到 ok </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左走</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j)) &#123;</span><br><span class="line"><span class="comment">//向下走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j+<span class="number">1</span>)) &#123; </span><br><span class="line"><span class="comment">//向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i-<span class="number">1</span>, j)) &#123; </span><br><span class="line"><span class="comment">//向上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j-<span class="number">1</span>))&#123; </span><br><span class="line"><span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 如果 map[i][j] != 0 , 可能是 1， 2， 3 </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果：</p><p><img src="https://i.loli.net/2019/12/15/E1Gq8AlD3Pg67IK.jpg" alt="188B5FE3-EBA9-4992-B231-CFE4CD0FB589.jpeg"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;迷宫找路径问题被广泛应用到生活中。比如游戏，玩过LOL的会发现右下角的地图，其实它就是一个典型的找路径问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="递归" scheme="yihao.ml/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>八皇后</title>
    <link href="yihao.ml/2019/12/15/2019%E2%80%9312-15-%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <id>yihao.ml/2019/12/15/2019–12-15-八皇后/</id>
    <published>2019-12-15T10:06:38.644Z</published>
    <updated>2020-11-15T10:13:04.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法?</p><p><img src="https://i.loli.net/2019/12/15/9ckTeuAQVwG1Rz7.jpg" alt="BF54C6BB-1CB9-4408-8438-95BC7819F8A8.jpeg"></p><p>在上个世纪，计算机不发达的时候，这个问题困惑着所有人。现在已经有相关算法算出最终结果是92种摆法。</p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>1.第一个皇后先放第一行第一列</p><p>2.第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p><p>3.继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p><p>4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p><p>5.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123; </span><br><span class="line"><span class="comment">//定义一个 max 表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//定义数组 array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//测试一把 ， 8 皇后是否正确</span></span><br><span class="line">Queue8 queue8 = <span class="keyword">new</span> Queue8(); </span><br><span class="line">queue8.check(<span class="number">0</span>); </span><br><span class="line">System.out.printf(<span class="string">"一共有%d 解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d 次"</span>, judgeCount); </span><br><span class="line"><span class="comment">// 1.5w </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//编写一个方法，放置第 n 个皇后</span></span><br><span class="line"><span class="comment">//特别注意： check 是 每一次递归时，进入到 check 中都有for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span>(n == max) &#123; </span><br><span class="line"><span class="comment">//n = 8 , 其实 8 个皇后就既然放好</span></span><br><span class="line">print(); </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123; </span><br><span class="line"><span class="comment">//先把当前这个皇后 n , 放到该行的第 1 列</span></span><br><span class="line">array[n] = i; </span><br><span class="line"><span class="comment">//判断当放置第 n 个皇后到 i 列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(judge(n)) &#123; </span><br><span class="line"><span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">//接着放 n+1 个皇后,即开始递归</span></span><br><span class="line">check(n+<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第 n 个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当我们放置第 n 个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 表示第 n 个皇后</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">judgeCount++; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">//1. array[i] == array[n] 表示判断 第 n 个皇后是否和前面的 n-1 个皇后在同一列</span></span><br><span class="line"><span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜线</span></span><br><span class="line"><span class="comment">// n = 1 放置第 2 列 1 n = 1 array[1] = 1 </span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 </span></span><br><span class="line"><span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">count++; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; </span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="递归" scheme="yihao.ml/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda IDEA</title>
    <link href="yihao.ml/2019/11/11/2019%E2%80%9311-12-Anacoda%20IDEA/"/>
    <id>yihao.ml/2019/11/11/2019–11-12-Anacoda IDEA/</id>
    <published>2019-11-11T16:06:13.903Z</published>
    <updated>2020-11-15T10:13:04.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>好的优秀的IDEA可以提高生产效率，下面介绍一下Python的常用IDEA。</p><p>PyCharm：复杂大型的企业级应用。<br>IDLE、Sublime ： 300+行的代码程序。<br>Anaconda：适合科学计算和数据分析。</p><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>Anacoda免费开源、支持8000个第三方库、包含多个主流工具，适合数据计算领域开发。下面了解一下里面的基本组件。</p><p>我们可以上www.continuum.io上安装最新的Anacoda IDEA。</p><p>它可以装在linux、win、mac上。实际上，Anacoda只是帮我们集成各类python工具，比如下面三个组件：</p><ul><li>Conda： 与pip和maven类似，是一个包管理工具用于管理第三方包。</li><li>Spyder： 它可以编写python代码，并且支持调试运行。</li><li>IPython： 是一个功能强大的交互式shell，编写代码变得更方便，适合进行交互式数据可视化和GUI相关应用开发，便于做数据分析。</li></ul><h3 id="conda"><a class="markdownIt-Anchor" href="#conda"></a> conda</h3><p>安装Anacoda ，打开Anacoda Navigator。在Environments一栏中可以看到默认的root环境空间，空间中已经包含了很多默认的第三方包。如果需要可以继续创建别的环境空间。</p><h3 id="spyder"><a class="markdownIt-Anchor" href="#spyder"></a> Spyder</h3><p>Spyder有三个工作区，分别为编辑区、文本导航和帮助区、IPython区</p><p>文本导航和帮助区我们不经常使用，建议删除掉简化开发页面。</p><p>在tools -&gt; perference -&gt; syntax coloring中可以设置主题</p><h3 id="ipython"><a class="markdownIt-Anchor" href="#ipython"></a> IPython</h3><p>In [num] : In指的是输入的命令，num是IPython的行号<br>Out [num] : Out指的是输出值或结果</p><p>下面介绍一下IPython中常用的两个指令：？和%</p><p>？跟在变量的后面，可以打印更多的详细信息。<br>%run <a href="http://file.py" target="_blank" rel="noopener">file.py</a> 可以运行任意目录下的file.py文件。</p><p>除上面命令以外，IPython还有很多其他指令，如下图所示：</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;好的优秀的IDEA可以提高生产效率，下面介绍一下Python的常用IDEA。&lt;/p&gt;&lt;p&gt;PyCharm：复杂大型的企业级应用。&lt;br&gt;IDLE、Subli
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Anaconda" scheme="yihao.ml/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>Flink基本概念（一）</title>
    <link href="yihao.ml/2019/11/11/2019%E2%80%9311-08-Flink%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>yihao.ml/2019/11/11/2019–11-08-Flink基本概念/</id>
    <published>2019-11-11T05:31:46.485Z</published>
    <updated>2020-11-15T10:13:04.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --><p>Flink是一个分布式、可拓展并行计算的流式计算引擎。大数据生态中，流式计算引擎还真不少，比如Spark、Storm；他们在处理数据时各有优缺点，那么Flink在流处理中，性能是不是要优于前两者，下面针对几个方面我们来快速的入个门。主要描述Flink中的基本概念。</p><h3 id="job-managers-task-managers-客户端clients"><a class="markdownIt-Anchor" href="#job-managers-task-managers-客户端clients"></a> Job Managers、Task Managers、客户端（Clients）</h3><p>下面简单说一说Flink中比较重要的三个组件，它们分别是JobManagers，TaskManagers，Client。</p><p><img src="https://i.loli.net/2019/11/11/BYN6pwKzoUgJEXk.png" alt="1AB09791-ABB6-4B9E-B8CF-5772F8D835BB.png"></p><h4 id="1什么是jobmanager"><a class="markdownIt-Anchor" href="#1什么是jobmanager"></a> 1.什么是JobManager？</h4><p>Job Managers，是整个应用的Master。它负责调度任务，协调checkpoint，协调故障恢复等。一个Job至少会有一个Job Manager。高可用部署下会有多个JobManagers，其中一个作为leader，其余的处于standby状态。</p><h4 id="2什么是taskmanagers"><a class="markdownIt-Anchor" href="#2什么是taskmanagers"></a> 2.什么是TaskManagers？</h4><p>TaskManagers，是整个应用的Workers。它主要执行dataflow中的tasks（更准确来说应该是subtasks），并且缓存和交换数据streams。每个job至少会有一个taskmanager。</p><h4 id="3什么是client"><a class="markdownIt-Anchor" href="#3什么是client"></a> 3.什么是client？</h4><p>client用户端主要负责提交DataFlow 到JobManager，取消或者更新Job。客户端的代码由Java或者Scala编写。运行代码指令如 flink run xxx.jar…</p><h4 id="4怎么启动jobmanagers和taskmanagers"><a class="markdownIt-Anchor" href="#4怎么启动jobmanagers和taskmanagers"></a> 4.怎么启动JobManagers和TaskManagers</h4><p>JobManagers和TaskManagers有多种启动方式：直接在机器上启动（standalone cluster）；在容器或资源管理框架中启动，比如Mesos、Yarn。后续我们会使用Yarn取启动JobManager</p><h3 id="task-和-subtasks"><a class="markdownIt-Anchor" href="#task-和-subtasks"></a> Task 和 SubTasks</h3><p>分布式计算中，Flink 将算子（operator）的 subtask 链接（chain）成 task。每个 task 由一个线程执行。把算子链接成 tasks 能够减少线程间切换和缓冲的开销，在降低延迟的同时提高了整体吞吐量。链接操作的配置详情可参考：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/stream/operators/#task-chaining-and-resource-groups" target="_blank" rel="noopener">chaining docs</a></p><p>下图的 dataflow 由五个 subtasks 执行，因此具有五个并行线程。</p><p><img src="https://i.loli.net/2019/11/11/gTNYUikXtphH9uz.png" alt="A290B58A-3250-43C5-848A-4865916DEB3E.png"></p><h3 id="task-slots和资源"><a class="markdownIt-Anchor" href="#task-slots和资源"></a> Task Slots和资源</h3><h4 id="1什么是slots槽"><a class="markdownIt-Anchor" href="#1什么是slots槽"></a> 1.什么是slots（槽）？</h4><p>flink中一个TaskManager中至少有一个slot（槽），每个Slot代表了TasManager的一份固定资源子集。subtasks实际运行在slot内，划分资源意味着subtask之间不会竞争资源，但是也意味着它们只拥有固定的资源。这里没有CPU的隔离，只是划分任务的内存资源。</p><p><img src="https://i.loli.net/2019/11/11/Fg9VWTZyKt6NEwk.png" alt="CE0C1C58-70EE-47AE-9135-7A8885527B86.png"></p><h4 id="2substasks怎么共享slot"><a class="markdownIt-Anchor" href="#2substasks怎么共享slot"></a> 2.substasks怎么共享slot</h4><p>在代码中可以使用slotSharingGroup（）函数来设置共享槽，如果不设置默认为default。</p><p>默认情况下，Flink 允许 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，只要它们来自同一个 job。因此，一个 slot 可能会负责这个 job 的整个管道（pipeline）。允许 slot sharing 有两个好处：</p><ul><li><p>Flink 集群需要与 job 中使用的最高并行度一样多的 slots。这样不需要计算作业总共包含多少个 tasks（具有不同并行度）。</p></li><li><p>更好的资源利用率。在没有 slot sharing 的情况下，简单的 subtasks（source/map()）将会占用和复杂的 subtasks （window）一样多的资源。通过 slot sharing，将示例中的并行度从 2 增加到 6 可以充分利用 slot 的资源，同时确保繁重的 subtask 在 TaskManagers 之间公平地获取资源。</p></li></ul><p><img src="https://i.loli.net/2019/11/11/g2wPquCrkO5exE1.png" alt="4B04802A-2045-468A-8085-B560661FD9C5.png"></p><p>参考资料:<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/concepts/runtime.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.9/concepts/runtime.html</a></p><h3 id="后续总结"><a class="markdownIt-Anchor" href="#后续总结"></a> 后续总结</h3><ul><li>Flink 部署方式，重点Flink on yarn</li><li>如何向yarn申请Flink运行资源（JobManager）</li><li>如何提交一个简单的Flink程序</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:11 GMT+0000 (GMT) --&gt;&lt;p&gt;Flink是一个分布式、可拓展并行计算的流式计算引擎。大数据生态中，流式计算引擎还真不少，比如Spark、Storm；他们在处理数据时各有优缺点，那么Fli
      
    
    </summary>
    
      <category term="大数据" scheme="yihao.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Flink" scheme="yihao.ml/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Kafka源码刨析之Produer Metadata更新机制（二）</title>
    <link href="yihao.ml/2019/11/07/2019-11-07-Kafka%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90%E4%B9%8BProduer%20Metadata%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>yihao.ml/2019/11/07/2019-11-07-Kafka源码刨析之Produer Metadata更新机制（二）/</id>
    <published>2019-11-07T12:01:15.067Z</published>
    <updated>2020-11-15T10:13:04.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --><p>在上一篇文章中，已经介绍了 Producer 的发送模型，Producer <code>dosend()</code> 方法中的第一步，就是获取相关的 topic 的 metadata，但在上篇中并没有深入展开，因为这部分的内容比较多，所以本文单独一篇文章进行介绍，本文主要来讲述以下三个问题：</p><pre><code>1. metadata 内容是什么；2. Producer 更新 metadata 的流程；3. Producer 在什么情况下会去更新 metadata；</code></pre><h3 id="metadata-内容"><a class="markdownIt-Anchor" href="#metadata-内容"></a> Metadata 内容</h3><p>Metadata 信息的内容可以通过源码看明白：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 这个类被 client 线程和后台 sender 所共享,它只保存了所有 topic 的部分数据,当我们请求一个它上面没有的 topic meta 时,它会通过发送 metadata update 来更新 meta 信息,</span><br><span class="line">// 如果 topic meta 过期策略是允许的,那么任何 topic 过期的话都会被从集合中移除,</span><br><span class="line">// 但是 consumer 是不允许 topic 过期的因为它明确地知道它需要管理哪些 topic</span><br><span class="line">public final class Metadata &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(Metadata.class);</span><br><span class="line"></span><br><span class="line">    public static final long TOPIC_EXPIRY_MS = 5 * 60 * 1000;</span><br><span class="line">    private static final long TOPIC_EXPIRY_NEEDS_UPDATE = -1L;</span><br><span class="line"></span><br><span class="line">    private final long refreshBackoffMs; // metadata 更新失败时,为避免频繁更新 meta,最小的间隔时间,默认 100ms</span><br><span class="line">    private final long metadataExpireMs; // metadata 的过期时间, 默认 60,000ms</span><br><span class="line">    private int version; // 每更新成功1次，version自增1,主要是用于判断 metadata 是否更新</span><br><span class="line">    private long lastRefreshMs; // 最近一次更新时的时间（包含更新失败的情况）</span><br><span class="line">    private long lastSuccessfulRefreshMs; // 最近一次成功更新的时间（如果每次都成功的话，与前面的值相等, 否则，lastSuccessulRefreshMs &lt; lastRefreshMs)</span><br><span class="line">    private Cluster cluster; // 集群中一些 topic 的信息</span><br><span class="line">    private boolean needUpdate; // 是都需要更新 metadata</span><br><span class="line">    /* Topics with expiry time */</span><br><span class="line">    private final Map&lt;String, Long&gt; topics; // topic 与其过期时间的对应关系</span><br><span class="line">    private final List&lt;Listener&gt; listeners; // 事件监控者</span><br><span class="line">    private final ClusterResourceListeners clusterResourceListeners; //当接收到 metadata 更新时, ClusterResourceListeners的列表</span><br><span class="line">    private boolean needMetadataForAllTopics; // 是否强制更新所有的 metadata</span><br><span class="line">    private final boolean topicExpiryEnabled; // 默认为 true, Producer 会定时移除过期的 topic,consumer 则不会移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 topic 的详细信息（leader 所在节点、replica 所在节点、isr 列表）都是在<code>Cluster</code>实例中保存的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 并不是一个全集,metadata的主要组成部分</span><br><span class="line">public final class Cluster &#123;</span><br><span class="line"></span><br><span class="line">    // 从命名直接就看出了各个变量的用途</span><br><span class="line">    private final boolean isBootstrapConfigured;</span><br><span class="line">    private final List&lt;Node&gt; nodes; // node 列表</span><br><span class="line">    private final Set&lt;String&gt; unauthorizedTopics; // 未认证的 topic 列表</span><br><span class="line">    private final Set&lt;String&gt; internalTopics; // 内置的 topic 列表</span><br><span class="line">    private final Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition; // partition 的详细信息</span><br><span class="line">    private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic; // topic 与 partition 的对应关系</span><br><span class="line">    private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic; //  可用（leader 不为 null）的 topic 与 partition 的对应关系</span><br><span class="line">    private final Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode; // node 与 partition 的对应关系</span><br><span class="line">    private final Map&lt;Integer, Node&gt; nodesById; // node 与 id 的对应关系</span><br><span class="line">    private final ClusterResource clusterResource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// org.apache.kafka.common.PartitionInfo</span><br><span class="line">// topic-partition: 包含 topic、partition、leader、replicas、isr</span><br><span class="line">public class PartitionInfo &#123;</span><br><span class="line">    private final String topic;</span><br><span class="line">    private final int partition;</span><br><span class="line">    private final Node leader;</span><br><span class="line">    private final Node[] replicas;</span><br><span class="line">    private final Node[] inSyncReplicas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cluster 实例主要是保存：</p><pre><code>1. ``broker.id`` 与 ``node`` 的对应关系；2. topic 与 partition （``PartitionInfo``）的对应关系；3. node 与 partition （``PartitionInfo``）的对应关系。</code></pre><h3 id="producer-的-metadata-更新流程"><a class="markdownIt-Anchor" href="#producer-的-metadata-更新流程"></a> Producer 的 Metadata 更新流程</h3><p>Producer 在调用 <code>dosend()</code> 方法时，第一步就是通过 <code>waitOnMetadata</code> 方法获取该 topic 的 metadata 信息.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 等待 metadata 的更新</span><br><span class="line">private ClusterAndWaitTime waitOnMetadata(String topic, Integer partition, long maxWaitMs) throws InterruptedException &#123;</span><br><span class="line">    metadata.add(topic);// 在 metadata 中添加 topic 后,如果 metadata 中没有这个 topic 的 meta，那么 metadata 的更新标志设置为了 true</span><br><span class="line">    Cluster cluster = metadata.fetch();</span><br><span class="line">    Integer partitionsCount = cluster.partitionCountForTopic(topic);// 如果 topic 已经存在 meta 中,则返回该 topic 的 partition 数,否则返回 null</span><br><span class="line"></span><br><span class="line">    // 当前 metadata 中如果已经有这个 topic 的 meta 的话,就直接返回</span><br><span class="line">    if (partitionsCount != null &amp;&amp; (partition == null || partition &lt; partitionsCount))</span><br><span class="line">        return new ClusterAndWaitTime(cluster, 0);</span><br><span class="line"></span><br><span class="line">    long begin = time.milliseconds();</span><br><span class="line">    long remainingWaitMs = maxWaitMs;</span><br><span class="line">    long elapsed;</span><br><span class="line"></span><br><span class="line">    // 发送 metadata 请求,直到获取了这个 topic 的 metadata 或者请求超时</span><br><span class="line">    do &#123;</span><br><span class="line">        log.trace(&quot;Requesting metadata update for topic &#123;&#125;.&quot;, topic);</span><br><span class="line">        int version = metadata.requestUpdate();// 返回当前版本号,初始值为0,每次更新时会自增,并将 needUpdate 设置为 true</span><br><span class="line">        sender.wakeup();// 唤起 sender，发送 metadata 请求</span><br><span class="line">        try &#123;</span><br><span class="line">            metadata.awaitUpdate(version, remainingWaitMs);// 等待 metadata 的更新</span><br><span class="line">        &#125; catch (TimeoutException ex) &#123;</span><br><span class="line">            // Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span><br><span class="line">            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        cluster = metadata.fetch();</span><br><span class="line">        elapsed = time.milliseconds() - begin;</span><br><span class="line">        if (elapsed &gt;= maxWaitMs)</span><br><span class="line">            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);// 超时</span><br><span class="line">        if (cluster.unauthorizedTopics().contains(topic))// 认证失败，对当前 topic 没有 Write 权限</span><br><span class="line">            throw new TopicAuthorizationException(topic);</span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    &#125; while (partitionsCount == null);// 不停循环,直到 partitionsCount 不为 null（即直到 metadata 中已经包含了这个 topic 的相关信息）</span><br><span class="line"></span><br><span class="line">    if (partition != null &amp;&amp; partition &gt;= partitionsCount) &#123;</span><br><span class="line">        throw new KafkaException(</span><br><span class="line">                String.format(&quot;Invalid partition given with record: %d is not in the range [0...%d).&quot;, partition, partitionsCount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ClusterAndWaitTime(cluster, elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 metadata 中不存在这个 topic 的 metadata，那么就请求更新 metadata，如果 metadata 没有更新的话，方法就一直处在 <code>do ... while</code> 的循环之中，在循环之中，主要做以下操作：</p><pre><code>1. ``metadata.requestUpdate()`` 将 metadata 的 ``needUpdate`` 变量设置为 true（强制更新），并返回当前的版本号（version），通过版本号来判断 metadata 是否完成更新；2. ``sender.wakeup()`` 唤醒 sender 线程，sender 线程又会去唤醒 NetworkClient 线程，NetworkClient 线程进行一些实际的操作（后面详细介绍）；3. ``metadata.awaitUpdate(version, remainingWaitMs)`` 等待 metadata 的更新。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 更新 metadata 信息（根据当前 version 值来判断）</span><br><span class="line">public synchronized void awaitUpdate(final int lastVersion, final long maxWaitMs) throws InterruptedException &#123;</span><br><span class="line">    if (maxWaitMs &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Max time to wait for metadata updates should not be &lt; 0 milli seconds&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long begin = System.currentTimeMillis();</span><br><span class="line">    long remainingWaitMs = maxWaitMs;</span><br><span class="line">    while (this.version &lt;= lastVersion) &#123;// 不断循环,直到 metadata 更新成功,version 自增</span><br><span class="line">        if (remainingWaitMs != 0)</span><br><span class="line">            wait(remainingWaitMs);// 阻塞线程，等待 metadata 的更新</span><br><span class="line">        long elapsed = System.currentTimeMillis() - begin;</span><br><span class="line">        if (elapsed &gt;= maxWaitMs)// timeout</span><br><span class="line">            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);</span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Metadata.awaitUpdate()</code> 方法中，线程会阻塞在 <code>while</code> 循环中，直到 metadata 更新成功或者 timeout。</p><p>从前面可以看出，此时 Producer 线程会阻塞在两个 <code>while</code> 循环中，直到 metadata 信息更新，那么 metadata 是如何更新的呢？如果有印象的话，前面应该已经介绍过了，主要是通过 <code>sender.wakeup()</code>来唤醒 sender 线程，间接唤醒 NetworkClient 线程，NetworkClient 线程来负责发送 Metadata 请求，并处理 Server 端的响应。</p><p>在 Kafka 源码分析之 Producer 发送模型（一） 中介绍 Producer 发送模型时，在第五步 <code>sender</code> 线程会调用 <code>NetworkClient.poll()</code> 方法进行实际的操作，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;</span><br><span class="line">        long metadataTimeout = metadataUpdater.maybeUpdate(now);// 判断是否需要更新 meta,如果需要就更新（请求更新 metadata 的地方）</span><br><span class="line">        try &#123;</span><br><span class="line">            this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;Unexpected error during I/O&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // process completed actions</span><br><span class="line">        long updatedNow = this.time.milliseconds();</span><br><span class="line">        List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();</span><br><span class="line">        handleAbortedSends(responses);</span><br><span class="line">        handleCompletedSends(responses, updatedNow);// 通过 selector 中获取 Server 端的 response</span><br><span class="line">        handleCompletedReceives(responses, updatedNow);// 在返回的 handler 中，会处理 metadata 的更新</span><br><span class="line">        handleDisconnections(responses, updatedNow);</span><br><span class="line">        handleConnections();</span><br><span class="line">        handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">        handleTimedOutRequests(responses, updatedNow);</span><br><span class="line"></span><br><span class="line">        // invoke callbacks</span><br><span class="line">        for (ClientResponse response : responses) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                response.onComplete();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;Uncaught error in request completion:&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return responses;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，主要会以下操作：</p><ul><li><code>metadataUpdater.maybeUpdate(now)</code>：判断是否需要更新 Metadata，如果需要更新的话，先与 Broker 建立连接，然后发送更新 metadata 的请求；</li><li>处理 Server 端的一些响应，这里主要讨论的是 <code>handleCompletedReceives(responses, updatedNow)</code> 方法，它会处理 Server 端返回的 Metadata 结果。</li></ul><p>先看一下 <code>metadataUpdater.maybeUpdate()</code> 的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public long maybeUpdate(long now) &#123;</span><br><span class="line">        // should we update our metadata?</span><br><span class="line">        // metadata 是否应该更新</span><br><span class="line">        long timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);// metadata 下次更新的时间（需要判断是强制更新还是 metadata 过期更新,前者是立马更新,后者是计算 metadata 的过期时间）</span><br><span class="line">        // 如果一条 metadata 的 fetch 请求还未从 server 收到恢复,那么时间设置为 waitForMetadataFetch（默认30s）</span><br><span class="line">        long waitForMetadataFetch = this.metadataFetchInProgress ? requestTimeoutMs : 0;</span><br><span class="line"></span><br><span class="line">        long metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</span><br><span class="line">        if (metadataTimeout &gt; 0) &#123;// 时间未到时,直接返回下次应该更新的时间</span><br><span class="line">            return metadataTimeout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = leastLoadedNode(now);// 选择一个连接数最小的节点</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            log.debug(&quot;Give up sending metadata request since no node is available&quot;);</span><br><span class="line">            return reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maybeUpdate(now, node); // 可以发送 metadata 请求的话,就发送 metadata 请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Add a metadata request to the list of sends if we can make one</span><br><span class="line">     */</span><br><span class="line">    // 判断是否可以发送请求,可以的话将 metadata 请求加入到发送列表中</span><br><span class="line">    private long maybeUpdate(long now, Node node) &#123;</span><br><span class="line">        String nodeConnectionId = node.idString();</span><br><span class="line"></span><br><span class="line">        if (canSendRequest(nodeConnectionId)) &#123;// 通道已经 ready 并且支持发送更多的请求</span><br><span class="line">            this.metadataFetchInProgress = true; // 准备开始发送数据,将 metadataFetchInProgress 置为 true</span><br><span class="line">            MetadataRequest.Builder metadataRequest; // 创建 metadata 请求</span><br><span class="line">            if (metadata.needMetadataForAllTopics())// 强制更新所有 topic 的 metadata（虽然默认不会更新所有 topic 的 metadata 信息，但是每个 Broker 会保存所有 topic 的 meta 信息）</span><br><span class="line">                metadataRequest = MetadataRequest.Builder.allTopics();</span><br><span class="line">            else // 只更新 metadata 中的 topics 列表（列表中的 topics 由 metadata.add() 得到）</span><br><span class="line">                metadataRequest = new MetadataRequest.Builder(new ArrayList&lt;&gt;(metadata.topics()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            log.debug(&quot;Sending metadata request &#123;&#125; to node &#123;&#125;&quot;, metadataRequest, node.id());</span><br><span class="line">            sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);/ 发送 metadata 请求</span><br><span class="line">            return requestTimeoutMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If there&apos;s any connection establishment underway, wait until it completes. This prevents</span><br><span class="line">        // the client from unnecessarily connecting to additional nodes while a previous connection</span><br><span class="line">        // attempt has not been completed.</span><br><span class="line">        if (isAnyNodeConnecting()) &#123;// 如果 client 正在与任何一个 node 的连接状态是 connecting,那么就进行等待</span><br><span class="line">            // Strictly the timeout we should return here is &quot;connect timeout&quot;, but as we don&apos;t</span><br><span class="line">            // have such application level configuration, using reconnect backoff instead.</span><br><span class="line">            return reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (connectionStates.canConnect(nodeConnectionId, now)) &#123;// 如果没有连接这个 node,那就初始化连接</span><br><span class="line">            // we don&apos;t have a connection to this node right now, make one</span><br><span class="line">            log.debug(&quot;Initialize connection to node &#123;&#125; for sending metadata request&quot;, node.id());</span><br><span class="line">            initiateConnect(node, now);// 初始化连接</span><br><span class="line">            return reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line">        return Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> // 发送 Metadata 请求   </span><br><span class="line"> private void sendInternalMetadataRequest(MetadataRequest.Builder builder,</span><br><span class="line">                                         String nodeConnectionId, long now) &#123;</span><br><span class="line">    ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, true);// 创建 metadata 请求</span><br><span class="line">    doSend(clientRequest, true, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，每次 Producer 请求更新 metadata 时，会有以下几种情况：</p><pre><code>1. 如果 node 可以发送请求，则直接发送请求；2. 如果该 node 正在建立连接，则直接返回；3. 如果该 node 还没建立连接，则向 broker 初始化链接。</code></pre><p>而 KafkaProducer 线程之前是一直阻塞在两个 while 循环中，直到 metadata 更新</p><pre><code>1. sender 线程第一次调用 ``poll()`` 方法时，初始化与 node 的连接；2. sender 线程第二次调用 ``poll()`` 方法时，发送 ``Metadata`` 请求；3. sender 线程第三次调用 ``poll()`` 方法时，获取 ``metadataResponse``，并更新 metadata。</code></pre><p>经过上述 sender 线程三次调用 poll()方法，所请求的 metadata 信息才会得到更新，此时 Producer 线程也不会再阻塞，开始发送消息。</p><p><code>NetworkClient</code> 接收到 Server 端对 Metadata 请求的响应后，更新 Metadata 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 处理任何已经完成的接收响应</span><br><span class="line">    private void handleCompletedReceives(List&lt;ClientResponse&gt; responses, long now) &#123;</span><br><span class="line">        for (NetworkReceive receive : this.selector.completedReceives()) &#123;</span><br><span class="line">            String source = receive.source();</span><br><span class="line">            InFlightRequest req = inFlightRequests.completeNext(source);</span><br><span class="line">            AbstractResponse body = parseResponse(receive.payload(), req.header);</span><br><span class="line">            log.trace(&quot;Completed receive from node &#123;&#125;, for key &#123;&#125;, received &#123;&#125;&quot;, req.destination, req.header.apiKey(), body);</span><br><span class="line">            if (req.isInternalRequest &amp;&amp; body instanceof MetadataResponse)// 如果是 meta 响应</span><br><span class="line">                metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);</span><br><span class="line">            else if (req.isInternalRequest &amp;&amp; body instanceof ApiVersionsResponse)</span><br><span class="line">                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body); // 如果是其他响应</span><br><span class="line">            else</span><br><span class="line">                responses.add(req.completed(body, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        // 处理 Server 端对 Metadata 请求处理后的 response</span><br><span class="line">        public void handleCompletedMetadataResponse(RequestHeader requestHeader, long now, MetadataResponse response) &#123;</span><br><span class="line">            this.metadataFetchInProgress = false;</span><br><span class="line">            Cluster cluster = response.cluster();</span><br><span class="line">            // check if any topics metadata failed to get updated</span><br><span class="line">            Map&lt;String, Errors&gt; errors = response.errors();</span><br><span class="line">            if (!errors.isEmpty())</span><br><span class="line">                log.warn(&quot;Error while fetching metadata with correlation id &#123;&#125; : &#123;&#125;&quot;, requestHeader.correlationId(), errors);</span><br><span class="line"></span><br><span class="line">            // don&apos;t update the cluster if there are no valid nodes...the topic we want may still be in the process of being</span><br><span class="line">            // created which means we will get errors and no nodes until it exists</span><br><span class="line">            if (cluster.nodes().size() &gt; 0) &#123;</span><br><span class="line">                this.metadata.update(cluster, now);// 更新 meta 信息</span><br><span class="line">            &#125; else &#123;// 如果 metadata 中 node 信息无效,则不更新 metadata 信息</span><br><span class="line">                log.trace(&quot;Ignoring empty metadata response with correlation id &#123;&#125;.&quot;, requestHeader.correlationId());</span><br><span class="line">                this.metadata.failedUpdate(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Producer Metadata 的更新策略</p><p>Metadata 会在下面两种情况下进行更新</p><pre><code>1. KafkaProducer 第一次发送消息时强制更新，其他时间周期性更新，它会通过 Metadata 的 lastRefreshMs, lastSuccessfulRefreshMs 这2个字段来实现；2. 强制更新： 调用 Metadata.requestUpdate() 将 needUpdate 置成了 true 来强制更新。</code></pre><p>在 NetworkClient 的 poll() 方法调用时，就会去检查这两种更新机制，只要达到其中一种，就行触发更新操作。</p><p>Metadata 的强制更新会在以下几种情况下进行：</p><pre><code>1. initConnect 方法调用时，初始化连接；2. ``poll()`` 方法中对 ``handleDisconnections()`` 方法调用来处理连接断开的情况，这时会触发强制更新；3. ``poll()`` 方法中对 ``handleTimedOutRequests()`` 来处理请求超时时；4. 发送消息时，如果无法找到 partition 的 leader；5. 处理 Producer 响应（handleProduceResponse），如果返回关于 Metadata 过期的异常，比如：没有 topic-partition 的相关 meta 或者 client 没有权限获取其 metadata。</code></pre><p>强制更新主要是用于处理各种异常情况。</p><p>转自：<a href="https://zhuanlan.zhihu.com/p/66190242" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66190242</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --&gt;&lt;p&gt;在上一篇文章中，已经介绍了 Producer 的发送模型，Producer &lt;code&gt;dosend()&lt;/code&gt; 方法中的第一步，就是获取相关的 to
      
    
    </summary>
    
      <category term="大数据" scheme="yihao.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="kafka" scheme="yihao.ml/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka源码刨析之Produer发送模型（一）</title>
    <link href="yihao.ml/2019/11/07/2019%E2%80%9311-07-KafkaProducer%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/"/>
    <id>yihao.ml/2019/11/07/2019–11-07-KafkaProducer源码刨析/</id>
    <published>2019-11-07T12:01:15.066Z</published>
    <updated>2020-11-15T10:13:04.585Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --><p>kafka是一个分布式的消息中间件，目前应用十分广泛。看源码不仅可以了解其底层的细节，同时，在看代码时，也能跟着大神们学到很多的编程技巧。</p><h3 id="kafkaproducer的使用"><a class="markdownIt-Anchor" href="#kafkaproducer的使用"></a> KafkaProducer的使用</h3><p>在Kafka中，Client端是由Java实现的，Server端是Scala实现的。下面我们从Client端开始，分析一下Kafaka中的Producer模型。开始之前我们先看一下怎么向Topic中生产数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by matt on 16/7/26.</span><br><span class="line"> */</span><br><span class="line">public class ProducerTest &#123;</span><br><span class="line">    private static String topicName;</span><br><span class="line">    private static int msgNum;</span><br><span class="line">    private static int key;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092,127.0.0.2:9092&quot;);</span><br><span class="line">        props.put(&quot;key.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;value.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        topicName = &quot;test&quot;;</span><br><span class="line">        msgNum = 10; // 发送的消息数</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line">        for (int i = 0; i &lt; msgNum; i++) &#123;</span><br><span class="line">            String msg = i + &quot; This is matt&apos;s blog.&quot;;</span><br><span class="line">            producer.send(new ProducerRecord&lt;String, String&gt;(topicName, msg));</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到如何向Topic中生产数据，Kafka在这方面封装的很好，只需要两步就可以完成操作：</p><pre><code>1. 初始化KafkaProducer类2. 调用send接口发送数据</code></pre><p>下面围绕着send接口开始展开。</p><h3 id="kafkaproducer中的send方法"><a class="markdownIt-Anchor" href="#kafkaproducer中的send方法"></a> KafkaProducer中的send方法</h3><p>用户使用producer.send发送数据，我们看一下send()的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 异步向一个 topic 发送数据</span><br><span class="line">@Override</span><br><span class="line">public Future&lt;RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record) &#123;</span><br><span class="line">    return send(record, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向 topic 异步地发送数据，当发送确认后唤起回调函数</span><br><span class="line">@Override</span><br><span class="line">public Future&lt;RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback) &#123;</span><br><span class="line">    // intercept the record, which can be potentially modified; this method does not throw exceptions</span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = this.interceptors == null ? record : this.interceptors.onSend(record);</span><br><span class="line">    return doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口最后会走一个doSend()方法，接着追进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) &#123;</span><br><span class="line">       TopicPartition tp = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           // 1.确认数据要发送到的 topic 的 metadata 是可用的</span><br><span class="line">           ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">           long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">           Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">           // 2.序列化 record 的 key 和 value</span><br><span class="line">           byte[] serializedKey;</span><br><span class="line">           try &#123;</span><br><span class="line">               serializedKey = keySerializer.serialize(record.topic(), record.key());</span><br><span class="line">           &#125; catch (ClassCastException cce) &#123;</span><br><span class="line">               throw new SerializationException(&quot;Can&apos;t convert key of class &quot; + record.key().getClass().getName() +</span><br><span class="line">                       &quot; to class &quot; + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                       &quot; specified in key.serializer&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           byte[] serializedValue;</span><br><span class="line">           try &#123;</span><br><span class="line">               serializedValue = valueSerializer.serialize(record.topic(), record.value());</span><br><span class="line">           &#125; catch (ClassCastException cce) &#123;</span><br><span class="line">               throw new SerializationException(&quot;Can&apos;t convert value of class &quot; + record.value().getClass().getName() +</span><br><span class="line">                       &quot; to class &quot; + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                       &quot; specified in value.serializer&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 3. 获取该 record 的 partition 的值（可以指定,也可以根据算法计算）</span><br><span class="line">           int partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">           int serializedSize = Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);</span><br><span class="line">           ensureValidRecordSize(serializedSize); // record 的字节超出限制或大于内存限制时,就会抛出 RecordTooLargeException 异常</span><br><span class="line">           tp = new TopicPartition(record.topic(), partition);</span><br><span class="line">           long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp(); // 时间戳</span><br><span class="line">           log.trace(&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;, record, callback, record.topic(), partition);</span><br><span class="line">           Callback interceptCallback = this.interceptors == null ? callback : new InterceptorCallback&lt;&gt;(callback, this.interceptors, tp);</span><br><span class="line">           // 4. 向 accumulator 中追加数据</span><br><span class="line">           RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue,interceptCallback, remainingWaitMs);</span><br><span class="line">           // 5. 如果 batch 已经满了,唤醒 sender 线程发送数据</span><br><span class="line">           if (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">               log.trace(&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;,record.topic(),partition);</span><br><span class="line">               this.sender.wakeup();</span><br><span class="line">           &#125;</span><br><span class="line">           return result.future;</span><br><span class="line">       &#125; catch (ApiException e) &#123;</span><br><span class="line">           log.debug(&quot;Exception occurred during message send:&quot;, e);</span><br><span class="line">           if (callback != null)</span><br><span class="line">               callback.onCompletion(null, e);</span><br><span class="line">           this.errors.record();</span><br><span class="line">           if (this.interceptors != null)</span><br><span class="line">               this.interceptors.onSendError(record, tp, e);</span><br><span class="line">           return new FutureFailure(e);</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           this.errors.record();</span><br><span class="line">           if (this.i nterceptors != null)</span><br><span class="line">               this.interceptors.onSendError(record, tp, e);</span><br><span class="line">           throw new InterruptException(e);</span><br><span class="line">       &#125; catch (BufferExhaustedException e) &#123;</span><br><span class="line">           this.errors.record();</span><br><span class="line">           this.metrics.sensor(&quot;buffer-exhausted-records&quot;).record();</span><br><span class="line">           if (this.interceptors != null)</span><br><span class="line">               this.interceptors.onSendError(record, tp, e);</span><br><span class="line">           throw e;</span><br><span class="line">       &#125; catch (KafkaException e) &#123;</span><br><span class="line">           this.errors.record();</span><br><span class="line">           if (this.interceptors != null)</span><br><span class="line">               this.interceptors.onSendError(record, tp, e);</span><br><span class="line">           throw e;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           if (this.interceptors != null)</span><br><span class="line">               this.interceptors.onSendError(record, tp, e);</span><br><span class="line">           throw e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 dosend() 方法的实现上，一条 Record 数据的发送，可以分为以下五步：</p><pre><code>1. 确认数据要发送到的 topic 的 metadata 是可用的（如果该 partition 的 leader 存在则是可用的，如果开启权限时，client 有相应的权限），如果没有 topic 的 metadata 信息，就需要获取相应的 metadata；2. 序列化 record 的 key 和 value；3. 获取该 record 要发送到的 partition（可以指定，也可以根据算法计算）；4. 向 accumulator 中追加 record 数据，数据会先进行缓存；5. 如果追加完数据后，对应的 RecordBatch 已经达到了 batch.size 的大小（或者batch 的剩余空间不足以添加下一条 Record），则唤醒 sender 线程发送数据。</code></pre><p>数据的发送过程，可以简单总结为以上五点，下面会这几部分的具体实现进行详细分析。</p><h2 id="发送的过程详解"><a class="markdownIt-Anchor" href="#发送的过程详解"></a> 发送的过程详解</h2><h3 id="获取-topic-的-metadata-信息"><a class="markdownIt-Anchor" href="#获取-topic-的-metadata-信息"></a> 获取 topic 的 metadata 信息</h3><p>Producer 通过 waitOnMetadata() 方法来获取对应 topic 的 metadata 信息，这部分后面会单独抽出一篇文章来介绍，这里就不再详述，总结起来就是：在数据发送前，需要先该 topic 是可用的。</p><h3 id="key-和-value-的序列化"><a class="markdownIt-Anchor" href="#key-和-value-的序列化"></a> key 和 value 的序列化</h3><p>Producer 端对 record 的 key 和 value 值进行序列化操作，在 Consumer 端再进行相应的反序列化，Kafka 内部提供的序列化和反序列化算法如下图所示：</p><p><img src="https://i.loli.net/2019/11/07/r4CtIEAcmhwN7xo.jpg" alt="D8B532DC-1C96-4778-875F-2466E5835EFA.jpeg"><br>Need support? Please accept cookies and refresh the page 😃</p><p>Kafka serialize &amp; deserialize</p><p>当然我们也是可以自定义序列化的具体实现，不过一般情况下，Kafka 内部提供的这些方法已经足够使用。</p><h3 id="获取-partition-值"><a class="markdownIt-Anchor" href="#获取-partition-值"></a> 获取 partition 值</h3><p>关于 partition 值的计算，分为三种情况：</p><p>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；<br>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；<br>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。<br>具体实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当 record 中有 partition 值时，直接返回，没有的情况下调用 partitioner 的类的 partition 方法去计算（KafkaProducer.class）</span><br><span class="line">private int partition(ProducerRecord&lt;K, V&gt; record, byte[] serializedKey, byte[] serializedValue, Cluster cluster) &#123;</span><br><span class="line">    Integer partition = record.partition();</span><br><span class="line">    return partition != null ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Producer 默认使用的<code>partitioner</code>是<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>，用户也可以自定义 partition 的策略，下面是这个类两个方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        int numPartitions = partitions.size();</span><br><span class="line">        if (keyBytes == null) &#123;// 没有指定 key 的情况下</span><br><span class="line">            int nextValue = nextValue(topic); // 第一次的时候产生一个随机整数,后面每次调用在之前的基础上自增;</span><br><span class="line">            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">            // leader 不为 null,即为可用的 partition</span><br><span class="line">            if (availablePartitions.size() &gt; 0) &#123;</span><br><span class="line">                int part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">                return availablePartitions.get(part).partition();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;// 有 key 的情况下,使用 key 的 hash 值进行计算</span><br><span class="line">            return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; // 选择 key 的 hash 值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据 topic 获取对应的整数变量</span><br><span class="line">    private int nextValue(String topic) &#123;</span><br><span class="line">        AtomicInteger counter = topicCounterMap.get(topic);</span><br><span class="line">        if (null == counter) &#123; // 第一次调用时，随机产生</span><br><span class="line">            counter = new AtomicInteger(new Random().nextInt());</span><br><span class="line">            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);</span><br><span class="line">            if (currentCounter != null) &#123;</span><br><span class="line">                counter = currentCounter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return counter.getAndIncrement(); // 后面再调用时，根据之前的结果自增</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 Producer 中默认的 partitioner 实现。</p><h3 id="向-accumulator-写数据"><a class="markdownIt-Anchor" href="#向-accumulator-写数据"></a> 向 accumulator 写数据</h3><p>Producer 会先将 record 写入到 buffer 中，当达到一个 batch.size 的大小时，再唤起 sender 线程去发送 RecordBatch（第五步），这里先详细分析一下 Producer 是如何向 buffer 中写入数据的。</p><p>Producer 是通过 RecordAccumulator 实例追加数据，RecordAccumulator 模型如下图所示，一个重要的变量就是 ConcurrentMap&lt;TopicPartition, Deque<recordbatch>&gt; batches，每个 TopicPartition 都会对应一个 Deque<recordbatch>，当添加数据时，会向其 topic-partition 对应的这个 queue 最新创建的一个 RecordBatch 中添加 record，而发送数据时，则会先从 queue 中最老的那个 RecordBatch 开始发送。</recordbatch></recordbatch></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![C89D1394-08D6-416D-814D-BC19D65091B2.jpeg](https://i.loli.net/2019/11/07/C6bS5ieDGfnAOsg.jpg)</span><br></pre></td></tr></table></figure><p>Producer RecordAccumulator 模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// org.apache.kafka.clients.producer.internals.RecordAccumulator</span><br><span class="line">     // 向 accumulator 添加一条 record，并返回添加后的结果（结果主要包含: future metadata、batch 是否满的标志以及新 batch 是否创建）其中， maxTimeToBlock 是 buffer.memory 的 block 的最大时间</span><br><span class="line">    public RecordAppendResult append(TopicPartition tp,</span><br><span class="line">                                     long timestamp,</span><br><span class="line">                                     byte[] key,</span><br><span class="line">                                     byte[] value,</span><br><span class="line">                                     Callback callback,</span><br><span class="line">                                     long maxTimeToBlock) throws InterruptedException &#123;</span><br><span class="line">        appendsInProgress.incrementAndGet();</span><br><span class="line">        try &#123;</span><br><span class="line">            Deque&lt;RecordBatch&gt; dq = getOrCreateDeque(tp);// 每个 topicPartition 对应一个 queue</span><br><span class="line">            synchronized (dq) &#123;// 在对一个 queue 进行操作时,会保证线程安全</span><br><span class="line">                if (closed)</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot send after the producer is closed.&quot;);</span><br><span class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq); // 追加数据</span><br><span class="line">                if (appendResult != null)// 这个 topic-partition 已经有记录了</span><br><span class="line">                    return appendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 为 topic-partition 创建一个新的 RecordBatch, 需要初始化相应的 RecordBatch，要为其分配的大小是: max（batch.size, 加上头文件的本条消息的大小）</span><br><span class="line">            int size = Math.max(this.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</span><br><span class="line">            log.trace(&quot;Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;&quot;, size, tp.topic(), tp.partition());</span><br><span class="line">            ByteBuffer buffer = free.allocate(size, maxTimeToBlock);// 给这个 RecordBatch 初始化一个 buffer</span><br><span class="line">            synchronized (dq) &#123;</span><br><span class="line">                if (closed)</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot send after the producer is closed.&quot;);</span><br><span class="line"></span><br><span class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">                if (appendResult != null) &#123;// 如果突然发现这个 queue 已经存在，那么就释放这个已经分配的空间</span><br><span class="line">                    free.deallocate(buffer);</span><br><span class="line">                    return appendResult;</span><br><span class="line">                &#125;</span><br><span class="line">                // 给 topic-partition 创建一个 RecordBatch</span><br><span class="line">                MemoryRecordsBuilder recordsBuilder = MemoryRecords.builder(buffer, compression, TimestampType.CREATE_TIME, this.batchSize);</span><br><span class="line">                RecordBatch batch = new RecordBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">                // 向新的 RecordBatch 中追加数据</span><br><span class="line">                FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">                dq.addLast(batch);// 将 RecordBatch 添加到对应的 queue 中</span><br><span class="line">                incomplete.add(batch);// 向未 ack 的 batch 集合添加这个 batch</span><br><span class="line">                // 如果 dp.size()&gt;1 就证明这个 queue 有一个 batch 是可以发送了</span><br><span class="line">                return new RecordAppendResult(future, dq.size() &gt; 1 || batch.isFull(), true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            appendsInProgress.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下其 record 写入的具体流程如下图所示：</p><p><img src="https://i.loli.net/2019/11/07/bL3CzBcH7G1f2Pe.jpg" alt="2EC40DD6-2B51-4F00-B2C7-CB6242E47B8F.jpeg"></p><p>Producer RecordAccumulator record 写入流程</p><p>获取该 topic-partition 对应的 queue，没有的话会创建一个空的 queue；<br>向 queue 中追加数据，先获取 queue 中最新加入的那个 RecordBatch，如果不存在或者存在但剩余空余不足以添加本条 record 则返回 null，成功写入的话直接返回结果，写入成功；<br>创建一个新的 RecordBatch，初始化内存大小根据 max(batch.size, Records.LOG_OVERHEAD + Record.recordSize(key, value)) 来确定（防止单条 record 过大的情况）；<br>向新建的 RecordBatch 写入 record，并将 RecordBatch 添加到 queue 中，返回结果，写入成功。</p><h3 id="发送-recordbatch"><a class="markdownIt-Anchor" href="#发送-recordbatch"></a> 发送 RecordBatch</h3><p>当 record 写入成功后，如果发现 RecordBatch 已满足发送的条件（通常是 queue 中有多个 batch，那么最先添加的那些 batch 肯定是可以发送了），那么就会唤醒 sender 线程，发送 RecordBatch。</p><p>sender 线程对 RecordBatch 的处理是在 run() 方法中进行的，该方法具体实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void run(long now) &#123;</span><br><span class="line">        Cluster cluster = metadata.fetch();</span><br><span class="line">        // 获取那些已经可以发送的 RecordBatch 对应的 nodes</span><br><span class="line">        RecordAccumulator.ReadyCheckResult result = this.accumulator.ready(cluster, now);</span><br><span class="line"></span><br><span class="line">        // 如果有 topic-partition 的 leader 是未知的,就强制 metadata 更新</span><br><span class="line">        if (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">            for (String topic : result.unknownLeaderTopics)</span><br><span class="line">                this.metadata.add(topic);</span><br><span class="line">            this.metadata.requestUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果与node 没有连接（如果可以连接,同时初始化该连接）,就证明该 node 暂时不能发送数据,暂时移除该 node</span><br><span class="line">        Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">        long notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">            Node node = iter.next();</span><br><span class="line">            if (!this.client.ready(node, now)) &#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">                notReadyTimeout = Math.min(notReadyTimeout, this.client.connectionDelay(node, now));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回该 node 对应的所有可以发送的 RecordBatch 组成的 batches（key 是 node.id）,并将 RecordBatch 从对应的 queue 中移除</span><br><span class="line">        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = this.accumulator.drain(cluster, result.readyNodes, this.maxRequestSize, now);</span><br><span class="line">        if (guaranteeMessageOrder) &#123;</span><br><span class="line">            //记录将要发送的 RecordBatch</span><br><span class="line">            for (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">                for (RecordBatch batch : batchList)</span><br><span class="line">                    this.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将由于元数据不可用而导致发送超时的 RecordBatch 移除</span><br><span class="line">        List&lt;RecordBatch&gt; expiredBatches = this.accumulator.abortExpiredBatches(this.requestTimeout, now);</span><br><span class="line">        for (RecordBatch expiredBatch : expiredBatches)</span><br><span class="line">            this.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</span><br><span class="line"></span><br><span class="line">        sensors.updateProduceRequestMetrics(batches);</span><br><span class="line"></span><br><span class="line">        long pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">        if (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">            log.trace(&quot;Nodes with data ready to send: &#123;&#125;&quot;, result.readyNodes);</span><br><span class="line">            pollTimeout = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 发送 RecordBatch</span><br><span class="line">        sendProduceRequests(batches, now);</span><br><span class="line"></span><br><span class="line">        this.client.poll(pollTimeout, now); // 关于 socket 的一些实际的读写操作（其中包括 meta 信息的更新）</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码前面有很多是其他的逻辑处理，如：移除暂时不可用的 node、处理由于元数据不可用导致的超时RecordBatch，真正进行发送发送RecordBatch的是sendProduceRequests(batches, now)这个方法，具体是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfer the record batches into a list of produce requests on a per-node basis</span><br><span class="line"> */</span><br><span class="line">private void sendProduceRequests(Map&lt;Integer, List&lt;RecordBatch&gt;&gt; collated, long now) &#123;</span><br><span class="line">    for (Map.Entry&lt;Integer, List&lt;RecordBatch&gt;&gt; entry : collated.entrySet())</span><br><span class="line">        sendProduceRequest(now, entry.getKey(), acks, requestTimeout, entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Create a produce request from the given record batches</span><br><span class="line"> */</span><br><span class="line">// 发送 produce 请求</span><br><span class="line">private void sendProduceRequest(long now, int destination, short acks, int timeout, List&lt;RecordBatch&gt; batches) &#123;</span><br><span class="line">    Map&lt;TopicPartition, MemoryRecords&gt; produceRecordsByPartition = new HashMap&lt;&gt;(batches.size());</span><br><span class="line">    final Map&lt;TopicPartition, RecordBatch&gt; recordsByPartition = new HashMap&lt;&gt;(batches.size());</span><br><span class="line">    for (RecordBatch batch : batches) &#123;</span><br><span class="line">        TopicPartition tp = batch.topicPartition;</span><br><span class="line">        produceRecordsByPartition.put(tp, batch.records());</span><br><span class="line">        recordsByPartition.put(tp, batch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProduceRequest.Builder requestBuilder =</span><br><span class="line">            new ProduceRequest.Builder(acks, timeout, produceRecordsByPartition);</span><br><span class="line">    RequestCompletionHandler callback = new RequestCompletionHandler() &#123;</span><br><span class="line">        public void onComplete(ClientResponse response) &#123;</span><br><span class="line">            handleProduceResponse(response, recordsByPartition, time.milliseconds());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String nodeId = Integer.toString(destination);</span><br><span class="line">    ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != 0, callback);</span><br><span class="line">    client.send(clientRequest, now);</span><br><span class="line">    log.trace(&quot;Sent produce request to &#123;&#125;: &#123;&#125;&quot;, nodeId, requestBuilder);</span><br></pre></td></tr></table></figure><p>这段代码就简单很多，总来起来就是，将 batches 中 leader 为同一个 node 的所有 RecordBatch 放在一个请求中进行发送。</p><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>本文是对 Kafka Producer 端发送模型的一个简单分析，下一篇文章将会详细介绍 metadata 相关的内容，包括 metadata 的内容以及在 Producer 端 metadata 的更新机制。</p><p>转自：<a href="https://zhuanlan.zhihu.com/p/66190242" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66190242</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 15 2020 10:13:12 GMT+0000 (GMT) --&gt;&lt;p&gt;kafka是一个分布式的消息中间件，目前应用十分广泛。看源码不仅可以了解其底层的细节，同时，在看代码时，也能跟着大神们学到很多的编程技巧。&lt;/p&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="大数据" scheme="yihao.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="kafka" scheme="yihao.ml/tags/kafka/"/>
    
  </entry>
  
</feed>
