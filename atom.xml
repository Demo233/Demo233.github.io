<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YIHAO&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="yihao.ml/"/>
  <updated>2020-12-01T12:12:50.364Z</updated>
  <id>yihao.ml/</id>
  
  <author>
    <name>Yihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Topological Sort</title>
    <link href="yihao.ml/2020/12/01/2020%E5%B9%B412%E6%9C%8801%E6%97%A518:40:33_TopologicalSort/"/>
    <id>yihao.ml/2020/12/01/2020年12月01日18:40:33_TopologicalSort/</id>
    <published>2020-12-01T18:40:25.000Z</published>
    <updated>2020-12-01T12:12:50.364Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>这里讨论一下拓扑排序，以及怎么检查有向图有没有带环。</p><h3 id="dag介绍"><a class="markdownIt-Anchor" href="#dag介绍"></a> DAG介绍</h3><p>DAG叫有向无环图，他描述了整个连通图中的某个子图不能带有环的，只要有环，就不能称为有向无环图。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/01/1606822347296-1606822347327.png" alt="title"></p><p>下图是错误的，带环的图。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/01/1606822388564-1606822388565.png" alt="title"></p><h3 id="拓扑排序介绍"><a class="markdownIt-Anchor" href="#拓扑排序介绍"></a> 拓扑排序介绍</h3><p>拓扑排序该算法在1972年设计编译器时被发明出来，当时的问题是，怎么解决代码编译的依赖问题。因为代码都是有顺序的，例如：C代码文件依赖B代码文件，B依赖A，B依赖D，那在编译时就不能先编译B，得将A和D先编译完了，才能编译B。所以编译的顺序要么是[A,D,B,C]，要么是[D,A,B,C]。拓扑排序可以将图转为顺序表，挨个打印这个表，就是正确的顺序了。</p><p>关于拓扑排序的实现有很多办法BFS、DFS、Kahn都可以实现，下面用Kahn实现以一下。</p><h3 id="kahn算法实现"><a class="markdownIt-Anchor" href="#kahn算法实现"></a> Kahn算法实现</h3><p>关于代码的实现不复杂下面简单理一下实现思路:</p><p>定义数据结构的时候，如果s需要先于t执⾏，那就添加⼀条s指向t的边。所以，如果某个顶点⼊度为0， 也就表示，没有任何顶点必须先于这个顶点执⾏，那么这个顶点就可以执⾏了。<br>我们先从图中，找出⼀个⼊度为0的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的⼊度都减1）。我们循环执⾏上⾯的过程，直到所有的顶点都被输出。最后输出的序列，就是满⾜局部依赖关系的拓扑排序。</p><p><strong>下面是代码简单思路</strong></p><ul><li>初始化图顶点的入度</li><li>将入度为0的顶点放到辅助队列T</li><li>当T不为空，就取出队列的顶点，并从T中删除</li><li>把取出的顶点放入队列Q中，并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的⼊度都减1），如果入度为0，将其放到T，等下次循环，否则什么都不做。</li></ul><p>下面Java实现拓扑排序（有向图是用邻接表的方式存储）：</p><blockquote><p>关于有向无环图的邻接表实现可以看一下这个<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/ListDG.java" target="_blank" rel="noopener">源码</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助队列T</span></span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(ListDG listDG)</span></span>&#123;</span><br><span class="line">    ListDG.VNode[] vNodes = listDG.getVNodes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[vNodes.length];</span><br><span class="line">    <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span>[vNodes.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vNodes.length; i++) &#123;</span><br><span class="line">        ListDG.ENode edges = vNodes[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span>(edges != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ins[edges.index]++;</span><br><span class="line">            edges = edges.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将入度为0的顶点放入到队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ins[i] == <span class="number">0</span>)</span><br><span class="line">            queue.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = queue.remove();</span><br><span class="line">        res[index++] = vNodes[v].data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到所有的边</span></span><br><span class="line">        ListDG.ENode edges = vNodes[v].firstEdge;</span><br><span class="line">        <span class="keyword">while</span>(edges != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里入度-1，就当做删除边操作了</span></span><br><span class="line">            ins[edges.index]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ins[edges.index] == <span class="number">0</span>)</span><br><span class="line">                queue.add(edges.index);</span><br><span class="line"></span><br><span class="line">            edges = edges.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index != vNodes.length)&#123;</span><br><span class="line">        System.out.println(<span class="string">"图有环"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历T队列</span></span><br><span class="line">    System.out.print(<span class="string">"图的拓扑排序结果为:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        System.out.print(res[i] + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法时间复杂度"><a class="markdownIt-Anchor" href="#算法时间复杂度"></a> 算法时间复杂度</h3><p>从Kahn代码中可以看出来，每个顶点被访问了⼀次，每个边也都被访问了⼀次，所以，Kahn算法的时间复杂度就是O(V+E)（V表示顶点个数，E表示边的个数）。</p><h3 id="图有没有带环"><a class="markdownIt-Anchor" href="#图有没有带环"></a> 图有没有带环</h3><p>其实检查环的问题。只适用于，已知一个图，检查图中环的场景，因为它的效率真的是太低了，要处理完整个图才能看到结果。比如场景：已知数据库中的所有顶点的依赖关系了，检查顶点间到底有没有环。这个问题，就需要⽤到拓扑排序算法了。我们把关系从数据库中加载到内存，然后构建成这种有向图数据结构，再利⽤拓扑排序，就可以快速检测出是否存在环了。</p><p>另外一种场景就是，插入一个关系以后，监测是否出现环，这时候再用拓扑排序显然性能有点low，下面介绍一个稍微好点的。举个例子比如下图:</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/01/1606823823344-1606823823348.png" alt="title"></p><p>这个时候插入C指向A的边以后，怎么监测带没带环？使用BFS或者DFS遍历顶点，用哈希表记录已访问过的顶点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; hashTable = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 保存已经访问过的vertex</span></span><br></pre></td></tr></table></figure><p>然后如果放的时候发现哈希表里面已经存在，那就意味着出现环了。</p><p>方便学习提供<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/TopologicalSort.java" target="_blank" rel="noopener">源码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;这里讨论一下拓扑排序，以及怎么检查有向图有没有带环。&lt;/p&gt;&lt;h3 id=&quot;dag介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Observer</title>
    <link href="yihao.ml/2020/11/29/2020-11-29_19-11-56_Observer/"/>
    <id>yihao.ml/2020/11/29/2020-11-29_19-11-56_Observer/</id>
    <published>2020-11-29T19:11:56.000Z</published>
    <updated>2020-12-01T12:12:50.361Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><h3 id="1-观察者模式简介"><a class="markdownIt-Anchor" href="#1-观察者模式简介"></a> 1. 观察者模式简介</h3><p>观察者模式描述了一对多的关系，让多个观察者监测到主题，当主题发生改变的时候，能够通知到观察者，让其能更新自己。这么说挺抽象的，我举一些实际应用的例子，如果你有一些开发经验的话，这些应用你肯定也用过。比如redis的发布-订阅功能、Java Swing编程里的源-监听器。</p><p>观察者模式中有两个概念比较重要，主题(Subject)又叫被观察者，观察者(Observer)。下图截选自百度百科<br><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/29/e7cd7b899e510fb3d7db4436d133c895d0430c54-1606650189080.png" alt="title"></p><ul><li>Observer - 观察者，其中定义好update方法</li><li>Subjedt - 抽象的主题，他是个抽象类，其中维护了Observers<ul><li>新增Observer</li><li>删除Observer</li><li>通知Observers的update方法</li></ul></li><li>ConcreteSubject - 具体的主题</li><li>ConcreateObserver - 具体的观察者</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="comment">// 主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector observerVector = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerOberver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerVector.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerVector.removeElement(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有注册的观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enumeration elements = observers();</span><br><span class="line">        <span class="keyword">while</span> (elements.hasMoreElements())&#123;</span><br><span class="line">            ((Observer) elements.nextElement()).update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration <span class="title">observers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Vector) observerVector.clone()).elements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am notified."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变主题的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newState)</span></span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        subject.registerOberver(observer);</span><br><span class="line"></span><br><span class="line">        subject.change(<span class="string">"123"</span>);</span><br><span class="line">        subject.change(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-java中的观察者模式"><a class="markdownIt-Anchor" href="#2-java中的观察者模式"></a> 2. Java中的观察者模式</h3><p>Java提供了实现观察者模式的方法，其中两个核心类，Observable和Observer</p><ul><li>Observer - 观察者,对应我们写的接口类Observer</li><li>Observable - 主题，对应我们写的抽象类Subject</li></ul><p>下面以问题：公鸡见到太阳升起，就打鸣为例，进行建模</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer.java.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sun</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"太阳升起"</span>);</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="comment">// 通知所有的观察者</span></span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer.java.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cock</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"公鸡打鸣"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer.java.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sun sun = <span class="keyword">new</span> Sun();</span><br><span class="line">        Cock cock = <span class="keyword">new</span> Cock();</span><br><span class="line">        sun.addObserver(cock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sun.rise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实际应用"><a class="markdownIt-Anchor" href="#3-实际应用"></a> 3. 实际应用</h3><p>最近写多线程代码是遇到了这样的问题，线程在用JDBC链接HiveServer2时因server不稳定，常常出现Timeout问题，联系运营发现，服务会在某时间段内重启，可能会有服务波动。</p><p>针对此问题，简单的思路就是在指定时间段内，发现timeout就重启线程。这里有两个类，观察者Restartor，线程JdbcQuerier。</p><ul><li>Restartor - 观察者，主要负责观察线程运行状态，并完成重启线程操作</li><li>JdbcQuerier - 被观察者，该类继承Runnable，在发生异常时，改变状态。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer.java.example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 观察者，用于重启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restartor</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"重启线程"</span>);</span><br><span class="line">        <span class="keyword">if</span>(condition1()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"检测到当前时间为9-10点,重启线程"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(((JdbcQuerier) o)).start();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(<span class="string">"检测到当前时间不是9-10点,不重启线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件1: 这里模拟重启条件，假如能被2整除就是是9-10点，9-10点也就是服务重启的时间，同样的你可以添加多个条件。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">condition1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> observer.java.example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: jdbc查询者,被观察对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcQuerier</span> <span class="keyword">extends</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"线程运行"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 查询数据库</span></span><br><span class="line">            queryData();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (TimeoutException e1)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"检测到Timeout异常"</span>);</span><br><span class="line">            <span class="keyword">this</span>.setChanged();</span><br><span class="line">            <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"检测到SQLException异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"线程终止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queryData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"获取连接"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"select * from tableName"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();    </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e1)&#123;</span><br><span class="line">            <span class="keyword">throw</span> e1;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (TimeoutException e2)&#123;</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"关闭连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer.java.example2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 被观察者</span></span><br><span class="line">        JdbcQuerier jdbcQuerier = <span class="keyword">new</span> JdbcQuerier();</span><br><span class="line">        <span class="comment">// 观察者</span></span><br><span class="line">        Restartor restartor = <span class="keyword">new</span> Restartor();</span><br><span class="line">        <span class="comment">//注册观察者</span></span><br><span class="line">        jdbcQuerier.addObserver(restartor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(jdbcQuerier);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便学习提供<a href="https://github.com/Demo233/design-pattern/tree/master/src/main/java/observer/java" target="_blank" rel="noopener">源码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;h3 id=&quot;1-观察者模式简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-观察者模式简介&quot;&gt;&lt;/a&gt; 1. 观察者模式简介
      
    
    </summary>
    
      <category term="设计模式" scheme="yihao.ml/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="yihao.ml/2020/11/28/2020-11-28_22:12:24_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95BFS/"/>
    <id>yihao.ml/2020/11/28/2020-11-28_22:12:24_广度优先遍历算法BFS/</id>
    <published>2020-11-28T22:12:24.000Z</published>
    <updated>2020-12-01T12:12:50.361Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>前文了解了如何用深度优先遍历算法去遍历图，本文换一种方式遍历图，广度优先遍历算法（Breath-First Search），下面用Java实现以下它。</p><h3 id="一-bfs介绍"><a class="markdownIt-Anchor" href="#一-bfs介绍"></a> 一. BFS介绍</h3><p>BFS它遍历的策略是：对于当前访问的顶点V，依次访问其所有的兄弟节点，直到遍历完为止，再以兄弟节点重复此操作，直到整个图遍历完为止。下面画个图来看看。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/28/1606573744520-1606573771391.jpg" alt="title"></p><p>BFS是这样的一个遍历思路，先找到顶点1并输出，找到1的第一个邻接点8并输出，第二个邻接点5输出，第三个顶点3输出，顶点1没有邻接点了；开始以8为顶点输出，8的第一个邻接点4输出，8的第二个邻接点1<strong>发现已经访问过了不作处理</strong>，顶点8没有邻接点了；开始以5为顶点输出，反复上面操作…那么打印的节点顺序就是1,8,5,3,4,2,6,11,9,7</p><h3 id="二代码说明"><a class="markdownIt-Anchor" href="#二代码说明"></a> 二.代码说明</h3><p>我们以邻接矩阵存储实现的图为基础，来实现BFS算法，邻接矩阵<a href="http://yihao.ml/2020/11/22/2020%E5%B9%B411%E6%9C%8822%E6%97%A514:11:18_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%9C%89%E5%90%91%E5%9B%BE/">有向图实现</a>和<a href="http://yihao.ml/2020/11/21/2020%E5%B9%B411%E6%9C%8821%E6%97%A522:45:32_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE/">无向图实现</a></p><p>首先以分治的思想将大问题划分为小问题，先解决一个顶点的深度搜索问题，在将此拓展到整个图上，也就解决了图的深度搜索问题。</p><h4 id="1-顶点i的深度搜索问题"><a class="markdownIt-Anchor" href="#1-顶点i的深度搜索问题"></a> 1. 顶点i的深度搜索问题</h4><p><strong>解决思路</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 将节点i输出记录已访问，并将节点放到队列T中</span><br><span class="line">2. T不为空开始循环</span><br><span class="line">3. 移除队头节点u</span><br><span class="line">4. 寻找u的邻接点w</span><br><span class="line">5. 如果w存在就循环，否则重复2</span><br><span class="line">6. 如果w没有访问过，就将其放到队列T，输出标记已访问，否则什么都不做</span><br><span class="line">7. 更新w，找u的下一个邻接点，重复5</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line">LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();<span class="comment">//辅助队列</span></span><br><span class="line"><span class="keyword">int</span> w; <span class="comment">// 第n个邻接点</span></span><br><span class="line"><span class="keyword">int</span> u; <span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];<span class="comment">// 已访问节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出i记录已访问，加入队列T</span></span><br><span class="line">    System.out.print(vertexs.get(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    queue.addLast(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T不为空就开始循环</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        u = queue.removeFirst();</span><br><span class="line">        <span class="comment">// 找到邻接点</span></span><br><span class="line">        w = firstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                <span class="comment">// 找到的邻接点没访问过，就输出记录已访问，加入队列T</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                System.out.print(vertexs.get(w) + <span class="string">"-&gt;"</span>);</span><br><span class="line">                visited[w] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 寻找下一个邻接点</span></span><br><span class="line">            w = nextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i2 + <span class="number">1</span>; j &lt; edge[i1].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i1][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[index].length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-图的深度搜索问题"><a class="markdownIt-Anchor" href="#2-图的深度搜索问题"></a> 2. 图的深度搜索问题</h4><p>上面我们已经将单个顶点的深度遍历问题解决了，下面只需要把方法套一下就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于所有的顶点vertexs，依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            bfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-时间复杂度分析"><a class="markdownIt-Anchor" href="#3-时间复杂度分析"></a> 3. 时间复杂度分析</h4><p>关于有n个顶点m条边的图来说时间复杂度是什么呢？可以考虑这样一个问题，对于最坏情况来讲，从最开始的顶点h，找到最终的顶点e，每一个顶点都要进出一次队列，每一个边都会被访问一次，因此时间复杂度O(n+m)。</p><p>对于一个连通图来讲，一般边m的都是大于n-1的，因此时间复杂度通常可以简化为O(m)</p><p>方便大家学习，查看<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/MatrixUDG.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;前文了解了如何用深度优先遍历算法去遍历图，本文换一种方式遍历图，广度优先遍历算法（Breath-First Search），下面用Java实现以下它。&lt;/p
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>SkipList</title>
    <link href="yihao.ml/2020/11/26/2020%E5%B9%B411%E6%9C%8826%E6%97%A523:52:26_%E8%B7%B3%E8%A1%A8/"/>
    <id>yihao.ml/2020/11/26/2020年11月26日23:52:26_跳表/</id>
    <published>2020-11-26T23:52:26.000Z</published>
    <updated>2020-12-01T12:12:50.364Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>本文我们用Java实现跳表的创建</p><h3 id="一-跳表介绍"><a class="markdownIt-Anchor" href="#一-跳表介绍"></a> 一. 跳表介绍</h3><p>我们知道单链表的查询时间复杂度为O(n)，那么有没有优化的办法呢？这里介绍一种数据结构，叫跳表，跳表应用十分广泛，比如最熟悉不过的redis，Redis中的有序集合（Sorted Set）就是⽤跳表来实现的。另外Java JUC中也有它的影子，想要了解的可以看下<code>ConcurrentSkipListMap</code>和<code>ConcurrentSkipListSet</code> ，其中底层实现都是使用了跳表。</p><p>之前提到如何优化链表的查询速度，想一下把二分查找的思想应用到单链表查找上，会是什么样？下面介绍一种办法，就是在链表上层创建索引，下面用一个图来解释。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/27/1606407069286-1606407081340.jpg" alt="title"></p><p>我们在原链表的基础上创建两级索引，比如查询16，如果没有索引，9次命中目标；而使用了2级索引，3次就命中了目标，不难发现这是一种使用空间换区时间的策略。</p><h3 id="二代码说明"><a class="markdownIt-Anchor" href="#二代码说明"></a> 二.代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node();  <span class="comment">// 带头链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> Node forwards[] = <span class="keyword">new</span> Node[MAX_LEVEL];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            builder.append(<span class="string">"&#123; data: "</span>);</span><br><span class="line">            builder.append(data);</span><br><span class="line">            builder.append(<span class="string">"; levels: "</span>);</span><br><span class="line">            builder.append(maxLevel);</span><br><span class="line">            builder.append(<span class="string">" &#125;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> builder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>head 是头结点,head.forwards[0]指的是原链表,head.forwards[1]指的是第一级索引,head.forwards[2]指的是第二级索引以此类推</li><li>levelCount 当前构造跳表索引的最大层数值</li><li>Node 是链表</li></ul><h4 id="2-插入实现"><a class="markdownIt-Anchor" href="#2-插入实现"></a> 2. 插入实现</h4><p><strong>动态更新</strong></p><p>在插入前需要考虑一个问题，索引的更新问题。如果我们不更新索引，只是单纯的插入节点，会造成索引间节点的值过多，查询速度退化问题。因此这边在插入时需要实时更新索引，一种简单的办法就是把原来的索引删了，重新创建索引。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/27/1606409160409-1606409181108.jpg" alt="title"></p><p><strong>概率算法</strong></p><p>我们不难发现原链表中节点个数为n，第一级索引节点个数为n/2，第二级索引节点个数为n/4，第m层索引节点个个数为n/2^m。不难发现，每层的节点个数都是有规律可循的，这里利用概率学推出概率函数randomLevel(),假定给一个值V，就能算出它的层L，通俗一些讲，对于插入的新值V，有50%几率建立一层索引，有25%的几率建立二层索引，有12.5%的概率建立三层索引…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> SKIPLIST_P = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。</span></span><br><span class="line"><span class="comment">// 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。</span></span><br><span class="line"><span class="comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span></span><br><span class="line"><span class="comment">//        50%的概率返回 1</span></span><br><span class="line"><span class="comment">//        25%的概率返回 2</span></span><br><span class="line"><span class="comment">//      12.5%的概率返回 3 ...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Redis 的Sorted set也同样使用了类似的算法，详情查看<a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c" target="_blank" rel="noopener">t_zset.c</a>，搜索<code>ZSKIPLIST_P</code>跳转到对应位置有兴趣的可以详细看一下。</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    # 获取层</span><br><span class="line">    <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">    </span><br><span class="line">    # 构造当前节点</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">    newNode.data = value;</span><br><span class="line">    newNode.maxLevel = level;</span><br><span class="line">    # 辅助数组，下表0代表是原链表，下表1代表是第一级索引，下表2代表第二级索引</span><br><span class="line">    Node update[] = <span class="keyword">new</span> Node[level];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">        update[i] = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找当前节点插入的位置。解释：对于索引高度为n的跳表 寻找与插入值紧挨着的最小值，将其放在辅助数组里</span></span><br><span class="line">    Node p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.forwards[i] != <span class="keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;</span><br><span class="line">            p = p.forwards[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点插入到每层的链表中的指定位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">        newNode.forwards[i] = update[i].forwards[i];</span><br><span class="line">        update[i].forwards[i] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新跳表索引的高度</span></span><br><span class="line">    <span class="keyword">if</span> (levelCount &lt; level) levelCount = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面方便学习提供<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/array/SkipList.java" target="_blank" rel="noopener">源码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;本文我们用Java实现跳表的创建&lt;/p&gt;&lt;h3 id=&quot;一-跳表介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-跳表介绍
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>ListDG</title>
    <link href="yihao.ml/2020/11/24/2020%E5%B9%B411%E6%9C%8824%E6%97%A522:58:10_%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%9C%89%E5%90%91%E5%9B%BE/"/>
    <id>yihao.ml/2020/11/24/2020年11月24日22:58:10_邻接表有向图/</id>
    <published>2020-11-24T22:58:10.000Z</published>
    <updated>2020-12-01T12:12:50.363Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>本文我们用Java实现邻接表有向图的创建。</p><h3 id="一-邻接表有向图介绍"><a class="markdownIt-Anchor" href="#一-邻接表有向图介绍"></a> 一. 邻接表有向图介绍</h3><p>邻接表底层使用了一个数组+链表来存储图，数组用于存储图的顶点，链表存储两个顶点之间的关系。如下图所示<br><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/25/1606234936018-1606234945778.jpg" alt="title"></p><h3 id="二代码说明"><a class="markdownIt-Anchor" href="#二代码说明"></a> 二.代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><p>这里定义还是和之前一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VNode[] vNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ENode</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边的索引</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 边的下一条边</span></span><br><span class="line">        ENode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span></span>&#123;</span><br><span class="line">        <span class="comment">// 顶点存储的值</span></span><br><span class="line">        <span class="keyword">char</span> data;</span><br><span class="line">        <span class="comment">// 顶底相连的第一条边</span></span><br><span class="line">        ENode firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-算法实现"><a class="markdownIt-Anchor" href="#2-算法实现"></a> 2. 算法实现</h4><p>这边只需要把创建边的方法稍作改动就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListDG</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">char</span>[][] edges)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v1 = vertexs.length;</span><br><span class="line">    vNodes = <span class="keyword">new</span> VNode[v1];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">        VNode vNode = <span class="keyword">new</span> VNode();</span><br><span class="line">        vNode.data = vertexs[i];</span><br><span class="line">        vNode.firstEdge = <span class="keyword">null</span>;</span><br><span class="line">        vNodes[i] = vNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取两条边对应的下标</span></span><br><span class="line">        <span class="keyword">int</span> p1 = getPos(edges[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> p2 = getPos(edges[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        ENode node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node1.index = p2;</span><br><span class="line">        <span class="keyword">if</span>(vNodes[p1].firstEdge == <span class="keyword">null</span>)</span><br><span class="line">            vNodes[p1].firstEdge = node1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(vNodes[p1].firstEdge, node1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便大家学习，提供了<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/DG.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;本文我们用Java实现邻接表有向图的创建。&lt;/p&gt;&lt;h3 id=&quot;一-邻接表有向图介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MatrixDG</title>
    <link href="yihao.ml/2020/11/22/2020%E5%B9%B411%E6%9C%8822%E6%97%A514:11:18_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%9C%89%E5%90%91%E5%9B%BE/"/>
    <id>yihao.ml/2020/11/22/2020年11月22日14:11:18_邻接矩阵有向图/</id>
    <published>2020-11-22T14:11:18.000Z</published>
    <updated>2020-12-01T12:12:50.363Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>前文我们介绍了邻接矩阵创建无向图，本文我们用Java实现邻接矩阵有向图的创建。</p><h3 id="一-邻接矩阵有向图介绍"><a class="markdownIt-Anchor" href="#一-邻接矩阵有向图介绍"></a> 一. 邻接矩阵有向图介绍</h3><p>有向图的应用方向也很广，比如微信中好友A可以添加B但是，B可以不添加A，再比如微博中的关注数，下图体现出了无向图和有向图的差异，同时还拓展了，第三种图，加权图。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/24/1606233556168-1606233568123.jpg" alt="title"></p><h3 id="二代码说明"><a class="markdownIt-Anchor" href="#二代码说明"></a> 二.代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><p>这里定义还是和之前一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixDG</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; vertexs;</span><br><span class="line">    <span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edge;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-算法实现"><a class="markdownIt-Anchor" href="#2-算法实现"></a> 2. 算法实现</h4><p>这边只需要把邻接矩阵无向图的<code>insertEdge</code>稍作改动就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向图和无向图的区别，仅仅是在插入边时做改动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    edge[v1][v2] = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(T i)</span> </span>&#123;</span><br><span class="line">    vertexs.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便大家学习，提供了<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/MatrixDG.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;前文我们介绍了邻接矩阵创建无向图，本文我们用Java实现邻接矩阵有向图的创建。&lt;/p&gt;&lt;h3 id=&quot;一-邻接矩阵有向图介绍&quot;&gt;&lt;a class=&quot;mark
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="yihao.ml/2020/11/21/2020%E5%B9%B411%E6%9C%8821%E6%97%A523:02:20_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/"/>
    <id>yihao.ml/2020/11/21/2020年11月21日23:02:20_深度优先遍历算法/</id>
    <published>2020-11-21T23:02:38.000Z</published>
    <updated>2020-12-01T12:12:50.363Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p></p><p>前文我们知道了如何创建无向图，分为邻接表和邻接矩阵两种方式，本文通过Java实现经典图的遍历算法-深度优先遍历算法(Depth First Search)</p><h3 id="一-dfs介绍"><a class="markdownIt-Anchor" href="#一-dfs介绍"></a> 一. DFS介绍</h3><p>深度优先遍历算法是一种算法，是一种遍历图的方法，在里面可以体会一下递归和回溯的思想。</p><p>讲一个寻找路径的小例子，方便理解比如“⾛迷宫”。 假设你站在迷宫的某个岔路⼝，然后想找到出⼝。你随意选择⼀个岔路⼝来⾛，⾛着⾛着发现⾛不通的时候，你就回退到上⼀ 个岔路⼝，重新选择⼀条路继续⾛，直到最终找到出⼝。这种⾛法就是⼀种深度优先搜索策略。</p><p>这⾥⾯实线箭头表示遍历，虚线箭头表示回退，从下图可以看到基本的行走路径。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/24/1606233135024-1606233153377.jpg" alt="title"></p><h3 id="二代码说明"><a class="markdownIt-Anchor" href="#二代码说明"></a> 二.代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><p>这里我们用邻接矩阵无向图的来做，在原有的基础上新增一个visited数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; vertexs;</span><br><span class="line">    <span class="comment">// 边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edge;</span><br><span class="line">    <span class="comment">// 已访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>visited 用一个数组来记录顶点是否已被访问</li></ul><h4 id="2-kahn算法实现"><a class="markdownIt-Anchor" href="#2-kahn算法实现"></a> 2. Kahn算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 输出访问的节点</span></span><br><span class="line">       System.out.print(vertexs.get(i).toString() + <span class="string">"=&gt;"</span>);</span><br><span class="line">       visited[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取i的第一个邻接点</span></span><br><span class="line">       <span class="keyword">int</span> w = firstNeighbor(i);</span><br><span class="line">       <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否访问过</span></span><br><span class="line">           <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line"><span class="comment">// 没有访问递归</span></span><br><span class="line">               dfs(w);</span><br><span class="line">           &#125;</span><br><span class="line">    <span class="comment">// 找下个邻接点</span></span><br><span class="line">           w = nextNeighbor(i, w);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 深度优先遍历算法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里对上面dfs(i)方法进行重载，dfs(i)是找一个点的所有邻接点，这里套一层意思就是找所有点的邻接点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">               dfs(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>⼴度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于⼀个连通图来说，也就是说⼀个图中的所有顶点都是连通的，E肯定要⼤于等于V-1，所以，⼴度优先搜索的时间复杂度也可以简写为O(E)。</p><p>方便大家学习，提供了<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/MatrixUDG.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前文我们知道了如何创建无向图，分为邻接表和邻接矩阵两种方式，本文通过Java实现经典图的遍历算法-深度优先遍历算法(Depth First
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>ListUDF</title>
    <link href="yihao.ml/2020/11/21/2020%E5%B9%B411%E6%9C%8821%E6%97%A523:01:34_%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>yihao.ml/2020/11/21/2020年11月21日23:01:34_邻接表无向图/</id>
    <published>2020-11-21T23:01:27.000Z</published>
    <updated>2020-12-01T12:12:50.362Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>前文我们通过邻接矩阵创建了无向图，本文通过Java实现邻接表创建无向图。</p><h3 id="一-邻接表无向图的介绍"><a class="markdownIt-Anchor" href="#一-邻接表无向图的介绍"></a> 一. 邻接表无向图的介绍</h3><p>邻接表无向图是一种数据结构，与之前邻接矩阵无向图不同的是，它使用链表来存储顶点的关系,也就是用链表存储边。如下面所示</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/25/1606234936018-1606234945778.jpg" alt="title"></p><blockquote><p>Tips: 之前用矩阵存储会造成空间上的额外开销，用链表就可以很好地改善，但代价是要花费更多的时间依次遍历链表每个节点。在实际工程中优化的话，可以考虑将链表换成<code>哈希表</code>、<code>跳表</code>或者是<code>红黑树</code></p></blockquote><h3 id="二-邻接矩阵无向图的代码说明"><a class="markdownIt-Anchor" href="#二-邻接矩阵无向图的代码说明"></a> 二. 邻接矩阵无向图的代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有的顶点</span></span><br><span class="line">    <span class="keyword">private</span> VNode[] vNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ENode</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边的索引</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 边的下一条边</span></span><br><span class="line">        ENode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span></span>&#123;</span><br><span class="line">        <span class="comment">// 顶点存储的值</span></span><br><span class="line">        <span class="keyword">char</span> data;</span><br><span class="line">        <span class="comment">// 顶底相连的第一条边</span></span><br><span class="line">        ENode firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vNodes 用于存储顶点值</li><li>ENode是边的数据结构，其实一个链表的表示形式</li><li>VNode实顶点的数据结构</li></ul><h4 id="2-创建图"><a class="markdownIt-Anchor" href="#2-创建图"></a> 2. 创建图</h4><p>创建图有两种方法，一种是已知数据创建图，一种是用户输入创建图。这里用的是前者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListUDG</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">char</span>[][] edges)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v1 = vertexs.length;</span><br><span class="line">        vNodes = <span class="keyword">new</span> VNode[v1];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            VNode vNode = <span class="keyword">new</span> VNode();</span><br><span class="line">            vNode.data = vertexs[i];</span><br><span class="line">            vNode.firstEdge = <span class="keyword">null</span>;</span><br><span class="line">            vNodes[i] = vNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取两条边对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPos(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> p2 = getPos(edges[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            ENode node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">            node1.index = p2;</span><br><span class="line">            <span class="keyword">if</span>(vNodes[p1].firstEdge == <span class="keyword">null</span>)</span><br><span class="line">                vNodes[p1].firstEdge = node1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkLast(vNodes[p1].firstEdge, node1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建无向图</span></span><br><span class="line">            ENode node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">            node2.index = p1;</span><br><span class="line">            <span class="keyword">if</span>(vNodes[p2].firstEdge == <span class="keyword">null</span>)</span><br><span class="line">                vNodes[p2].firstEdge = node2;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkLast(vNodes[p2].firstEdge, node2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方便大家学习，提供了<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/ListUDF.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;前文我们通过邻接矩阵创建了无向图，本文通过Java实现邻接表创建无向图。&lt;/p&gt;&lt;h3 id=&quot;一-邻接表无向图的介绍&quot;&gt;&lt;a class=&quot;markdo
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MatrixUDG</title>
    <link href="yihao.ml/2020/11/21/2020%E5%B9%B411%E6%9C%8821%E6%97%A522:45:32_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>yihao.ml/2020/11/21/2020年11月21日22:45:32_邻接矩阵无向图/</id>
    <published>2020-11-21T22:46:03.000Z</published>
    <updated>2020-12-01T12:12:50.362Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>本文通过Java实现邻接矩阵无向图。</p><h3 id="一-邻接矩阵无向图的介绍"><a class="markdownIt-Anchor" href="#一-邻接矩阵无向图的介绍"></a> 一. 邻接矩阵无向图的介绍</h3><p>邻接矩阵无向图是一种数据结构，其利用数组存储顶点，二维数组存储顶点之间的关系来存储数据。如下面所示</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/25/1606233939308-1606233950964.jpg" alt="title"></p><blockquote><p>Tips: 不难发现它是用空间换时间的策略，这么存边会造成很大的空间浪费，对于顶点关系的检索速度会很快。优化的话可以考虑使用稀疏数组来替换二维数组。同样的策略也适用于<code>邻接矩阵有向图</code></p></blockquote><h3 id="二-邻接矩阵无向图的代码说明"><a class="markdownIt-Anchor" href="#二-邻接矩阵无向图的代码说明"></a> 二. 邻接矩阵无向图的代码说明</h3><h4 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. 基本定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; vertexs;</span><br><span class="line">    <span class="comment">// 边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vertexs 用于存储顶点值</li><li>edge用于存储各个顶点的关系，我们把这种关系称之为<code>边</code></li></ul><h4 id="2-创建图"><a class="markdownIt-Anchor" href="#2-创建图"></a> 2. 创建图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Graph(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    vertexs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    edge = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(T vertex)</span></span>&#123;</span><br><span class="line">    vertexs.add(vertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    edge[v1][v2] = weight;</span><br><span class="line">    edge[v2][v1] = weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便大家学习，提供了<a href="https://github.com/Demo233/algorithm/blob/master/src/main/java/com/paic/graph/MatrixUDG.java" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;本文通过Java实现邻接矩阵无向图。&lt;/p&gt;&lt;h3 id=&quot;一-邻接矩阵无向图的介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="yihao.ml/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Hadoop</title>
    <link href="yihao.ml/2020/11/15/2020%E5%B9%B411%E6%9C%8815%E6%97%A514:11:53_%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop/"/>
    <id>yihao.ml/2020/11/15/2020年11月15日14:11:53_使用docker部署hadoop/</id>
    <published>2020-11-15T11:02:07.000Z</published>
    <updated>2020-12-01T12:12:50.362Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>首先我们构建一个jdk1.8+centos基础镜像，由于网上已经有很多现成的轮子，这里就不自己造了</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ryaning/centos-ssh</span><br></pre></td></tr></table></figure><h2 id="一-构建基础镜像"><a class="markdownIt-Anchor" href="#一-构建基础镜像"></a> 一、构建基础镜像</h2><p>如果镜像下载不下来，可以使用下面方法自己创建基础镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 Dockerfile</span></span><br><span class="line">vi Dockerfile</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">新增以下内容</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基础镜像</span></span><br><span class="line">FROM ryaning/centos-ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 作者</span></span><br><span class="line">MAINTAINER  Ryan &lt;me@ryana.cn&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">ADD jdk-8u162-linux-x64.tar.gz /usr/local/</span><br><span class="line">RUN mv /usr/local/jdk1.8.0_162 /usr/local/jdk1.8</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">ADD hadoop-2.9.2.tar.gz /usr/local</span><br><span class="line">RUN mv /usr/local/hadoop-2.9.2 /usr/local/hadoop</span><br><span class="line">ENV HADOOP_HOME /usr/local/hadoop</span><br><span class="line">ENV PATH $HADOOP_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">RUN yum install -y which sudo</span><br></pre></td></tr></table></figure><h2 id="二-搭建hadoop集群"><a class="markdownIt-Anchor" href="#二-搭建hadoop集群"></a> 二、 搭建hadoop集群</h2><h3 id="规划"><a class="markdownIt-Anchor" href="#规划"></a> 规划</h3><p>准备搭建一个具有三个节点的集群,1 master 2 slave</p><ul><li>master: hadoop0 ip: 192.168.10.10</li><li>salve1: hadoop1 ip: 192.168.10.11</li><li>salve2: hadoop2 ip: 192.168.10.12</li></ul><h3 id="配置ip"><a class="markdownIt-Anchor" href="#配置ip"></a> 配置IP</h3><p>docker 容器在启动时默认使用的是 bridge 模式，docker 容器启动后，会连接到一个名为 docker0 的虚拟网桥，故每次启动 docker 容器的 IP 都不是固定的，不方便管理，有时候需要进行固定 IP 映射，比如 docker 集群管理时。docker 在 1.9 版本版后，提供了创建自定义网络功能命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建自定义网络 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip段为：192.168.10.1/24，名字为：hadoop</span></span><br><span class="line">docker network create --subnet=192.168.10.1/24 hadoop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示自定义网络列表</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>运行3个 hadoop 容器，分别命名为 hadoop0，hadoop1，hadoop2，其中 hadoop0 作为 master， 并且映射了端口号，50070 和 8088，用来在浏览器中访问 hadoop WEB 界面的。</p><h4 id="命令说明"><a class="markdownIt-Anchor" href="#命令说明"></a> 命令说明：</h4><ul><li>-e TZ=“Asia/Shanghai” 增加环境变量，指定时区</li><li>-v /etc/localtime:/etc/localtime:ro：挂载系统时间到容器内</li><li>–net hadoop --ip 192.168.10.10：配置 Hadoop 集群节点的固定 IP</li><li>–add-host hadoop1:192.168.10.11：除了需要配置好 Hadoop 集群节点的固定 IP 外，还需要修改 Hadoop 容器内部的 hosts 文件，设置主机名与 ip 的映射。在 docker 中直接修改 /etc/hosts 文件，在重启容器后会被重置、覆盖。因此需要通过容器启动脚本 docker run 的 --add-host 参数将主机和 ip 地址的对应关系传入，容器在启动后会写入 hosts 文件中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hadoop0</span></span><br><span class="line">docker run --name hadoop0 \</span><br><span class="line">--hostname hadoop0 \</span><br><span class="line">--net hadoop --ip 192.168.10.10 \</span><br><span class="line">--add-host hadoop1:192.168.10.11 \</span><br><span class="line">--add-host hadoop2:192.168.10.12 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-d -P ryaning/hadoop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> hadoop1</span></span><br><span class="line">docker run --name hadoop1 \</span><br><span class="line">--hostname hadoop1 \</span><br><span class="line">--net hadoop --ip 192.168.10.11 \</span><br><span class="line">--add-host hadoop0:192.168.10.10 \</span><br><span class="line">--add-host hadoop2:192.168.10.12 \</span><br><span class="line">-d -P ryaning/hadoop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> hadoop2</span></span><br><span class="line">docker run --name hadoop2 \</span><br><span class="line">--hostname hadoop2 \</span><br><span class="line">--net hadoop --ip 192.168.10.12 \</span><br><span class="line">--add-host hadoop0:192.168.10.10 \</span><br><span class="line">--add-host hadoop1:192.168.10.11 \</span><br><span class="line">-d -P ryaning/hadoop</span><br></pre></td></tr></table></figure><h3 id="设置-ssh-免密码登录"><a class="markdownIt-Anchor" href="#设置-ssh-免密码登录"></a> 设置 SSH 免密码登录</h3><p>前面已经为容器配置 IP 了，在进行 ssh 时需要输入要登陆的容器的 root 密码，Hadoop 集群要求集群间机器 SSH 连接时无密码登陆，下面讲述容器间如何配置 SSH 无密码登陆。</p><p>以 hadoop0 容器为例，hadoop1、hadoop2 容器同样需要修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 hadoop0 容器内</span></span><br><span class="line">docker exec -it hadoop0 bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后会有多个输入提示，不用输入任何内容，全部直接回车即可</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令后需要输入登录密码，**默认为 123456**</span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop0</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop1</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@hadoop2</span><br></pre></td></tr></table></figure><h3 id="修改-hadoop-配置文件"><a class="markdownIt-Anchor" href="#修改-hadoop-配置文件"></a> 修改 Hadoop 配置文件</h3><p>要想真正的运行 hadoop 应用还需要修改 hadoop 运行参数；以 hadoop0 为例，进入到容器内 /usr/local/hadoop/etc/hadoop 目录下，需要修改的可执行文件与配置文件包括：<a href="http://hadoop-env.sh" target="_blank" rel="noopener">hadoop-env.sh</a>、<a href="http://yarn-env.sh" target="_blank" rel="noopener">yarn-env.sh</a>、core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml。</p><ul><li><a href="http://hadoop-env.sh" target="_blank" rel="noopener">hadoop-env.sh</a></li></ul><p>注释掉原有的配置 export JAVA_HOME=${JAVA_HOME}，修改成当前的 export JAVA_HOME=/usr/local/jdk1.8。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* yarn-env.sh</span><br><span class="line"></span><br><span class="line">同样是重新指定 export JAVA_HOME=/usr/local/jdk1.8。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/jdk1.8</span><br></pre></td></tr></table></figure><ul><li>core-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 HDFS 中 NameNode 的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop0:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 hadoop 运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.trash.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>1440<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>hdfs-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yarn-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop0:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mapred-site.xml</li></ul><p>这个文件默认不存在，需要从 mapred-site.xml.template 复制过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>slaves 配置</li></ul><p>修改 hadoop0 中的从机（slaves）配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vi /usr/local/hadoop/etc/hadoop/slaves</span><br></pre></td></tr></table></figure><p>删除原来的所有内容，修改为如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop1</span><br><span class="line">hadoop2</span><br></pre></td></tr></table></figure><h3 id="hadoop-集群配置分发"><a class="markdownIt-Anchor" href="#hadoop-集群配置分发"></a> hadoop 集群配置分发</h3><p>在 hadoop0 中执行命令，将 hadoop0 中的配置复制到其他两个节点中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/local/hadoop hadoop1:/usr/local</span><br><span class="line">scp -r /usr/local/hadoop hadoop2:/usr/local</span><br></pre></td></tr></table></figure><h2 id="三-启动"><a class="markdownIt-Anchor" href="#三-启动"></a> 三、启动</h2><p>第一次启动集群时，需要初始化</p><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p>出现类似下面命令说明格式化成功。</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/15/Snipaste_2020-11-15_14-51-19-1605424306303.png" alt="title"></p><blockquote><p>注：格式化操作不能重复执行。如果一定要重复格式化，带参数 -force 即可。</p></blockquote><h3 id="启动-hadoop-集群"><a class="markdownIt-Anchor" href="#启动-hadoop-集群"></a> 启动 hadoop 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/<span class="built_in">local</span>/hadoop 目录下执行</span></span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>注：在主节点 hadoop0 启动 hadoop，从节点 hadoop1、hadoop2 会自动启动。</p><p>浏览器中访问</p><p><img src="https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/11/15/Snipaste_2020-11-15_15-13-58-1605424469022.png" alt="title"></p><h2 id="四-验证集群是否正常"><a class="markdownIt-Anchor" href="#四-验证集群是否正常"></a> 四、验证集群是否正常</h2><p>可以正常访问的话，说明集群启动成功了，但不一定能正常运行，还需要下面的实际验证。</p><h3 id="测试验证"><a class="markdownIt-Anchor" href="#测试验证"></a> 测试验证</h3><p>创建本地测试文件，在 /opt 目录下创建测试文件目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir wcinput</span><br><span class="line">cd wcinput</span><br><span class="line">vi wc.input</span><br></pre></td></tr></table></figure><p>wc.input文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop mapreduce</span><br><span class="line">hadoop yarn</span><br><span class="line">hadoop hdfs</span><br><span class="line">mapreduce spark</span><br><span class="line">hadoop hello</span><br></pre></td></tr></table></figure><p>创建 HDFS 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /user/hadoop/input</span><br></pre></td></tr></table></figure><p>上传文件，把测试文件上传到刚刚创建的目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put /opt/wcinput/wc.input /user/hadoop/input</span><br></pre></td></tr></table></figure><p>查看文件上传是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /user/hadoop/input</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -ls /user/hadoop/input</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--   1 root supergroup         70 2019-01-21 10:07 /user/hadoop/input/wc.input</span><br><span class="line">[root@hadoop0 wcinput]#</span><br></pre></td></tr></table></figure><p>运行 mapreduce 程序</p><p>hadoop 安装包中提供了一个示例程序，我们可以使用它对刚刚上传的文件进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount /user/hadoop/input /user/hadoop/output</span><br></pre></td></tr></table></figure><blockquote><p>注：在执行过程中，如果长时间处于 Running 状态不动，虽然没有报错，但实际上是出错了，后台在不断重试，需要到 logs 目录下（/usr/local/hadoop/logs）查看日志文件中的错误信息。</p></blockquote><p>查看输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /user/hadoop/output</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -ls /user/hadoop/output</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 root supergroup          0 2019-01-22 05:35 /user/hadoop/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 root supergroup         51 2019-01-22 05:35 /user/hadoop/output/part-r-00000</span><br></pre></td></tr></table></figure><p>_SUCCESS 表示 HDFS 文件状态，生成的结果在 part-r-00000 中查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat /user/hadoop/output/part-r-00000</span><br><span class="line">[root@hadoop0 wcinput]# hdfs dfs -cat /user/hadoop/output/part-r-00000</span><br><span class="line">hadoop    4</span><br><span class="line">hdfs    1</span><br><span class="line">hello    1</span><br><span class="line">mapreduce    2</span><br><span class="line">spark    1</span><br><span class="line">yarn    1</span><br><span class="line">[root@hadoop0 wcinput]#</span><br></pre></td></tr></table></figure><p>以上就是使用 Docker 环境搭建 Hadoop 镜像容器，配置 Hadoop 集群，并启动和测试的实例，测试用的是 hadoop 官方给的一个 wordcount 统计，利用 hadoop 安装包里的 mapreduce 示例 jar 计算指定 HDFS 文件里的单词数，并将结果输出到指定 HDFS 目录。后面会介绍 HDFS 常用文件操作命令。</p><p>links: <a href="https://book.ryana.cn/hadoop/docker-install-hadoop.html" target="_blank" rel="noopener">https://book.ryana.cn/hadoop/docker-install-hadoop.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;首先我们构建一个jdk1.8+centos基础镜像，由于网上已经有很多现成的轮子，这里就不自己造了&lt;/p&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>高效VIM编辑器</title>
    <link href="yihao.ml/2020/11/15/2020%E5%B9%B411%E6%9C%8815%E6%97%A513:38:15_%E9%AB%98%E6%95%88VIM%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>yihao.ml/2020/11/15/2020年11月15日13:38:15_高效VIM编辑器/</id>
    <published>2020-11-15T11:02:07.000Z</published>
    <updated>2020-12-01T12:12:50.361Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率</p><h2 id="vim-中自定义快捷键"><a class="markdownIt-Anchor" href="#vim-中自定义快捷键"></a> Vim 中自定义快捷键</h2><p>map系列命令<br>这个命令的声明如下: :map {lhs} {rhs}。这个命令就是将{lhs}代表的按键映射成{rhs}所代表的按键。例如map L 就是将键映射成L。此外需要注意的是map命令定义的快捷键是可以嵌套的，例如下面这样的命令:</p><p>map L $<br>map Y yL</p><p>就是将Y按键映射成了y$按键。</p><p>更多详情参考:<a href="https://www.cnblogs.com/boldness2012/p/12432792.html" target="_blank" rel="noopener">https://www.cnblogs.com/boldness2012/p/12432792.html</a></p><h2 id="vim默认设置"><a class="markdownIt-Anchor" href="#vim默认设置"></a> Vim默认设置</h2><p>在<code>.vimrc</code>文件中添加下面内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用高亮</span></span><br><span class="line">syntax <span class="built_in">enable</span>                                                                                                           </span><br><span class="line"><span class="comment"># 设置行号</span></span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="comment"># 设置卡尺</span></span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="comment"># 高亮当前行</span></span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="comment"># F4 格式化JSON内容</span></span><br><span class="line">map &lt;F4&gt; &lt;Esc&gt;:%!python -m json.tool&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>第8行是格式化json的快捷键设置，在vim模式下按F4即可格式化Json数据</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;学习一些vim快捷键和自定义vim快捷键可以提高我们的开发效率&lt;/p&gt;&lt;h2 id=&quot;vim-中自定义快捷键&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
      <category term="其他" scheme="yihao.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Linux" scheme="yihao.ml/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>软链接解决磁盘不足</title>
    <link href="yihao.ml/2020/10/05/2020%E2%80%9310-05-%E8%BD%AF%E9%93%BE%E6%8E%A5%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3/"/>
    <id>yihao.ml/2020/10/05/2020–10-05-软链接解决磁盘不足/</id>
    <published>2020-10-05T13:59:52.000Z</published>
    <updated>2020-12-01T12:12:50.361Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>本人使用Linux系统作为主系统，在装系统时，分区分的有些小，导致现在装点东西都很难办。</p><h2 id="1操作系统"><a class="markdownIt-Anchor" href="#1操作系统"></a> 1.操作系统</h2><p><img src="http://qgw3wcroi.hn-bkt.clouddn.com/snapshot.png" alt="xx"></p><h2 id="2问题"><a class="markdownIt-Anchor" href="#2问题"></a> 2.问题</h2><p>因为ubuntu中安装软件，大部分都是这样<code>sudo apt-get install mysql</code> 往往我们都不自定义安装路径，这样导致我的其它磁盘空间很大，根目录空间严重不足。</p><p>网上有说清缓存、清理不用的软件、拓展系统分区，这些方案要么是不靠谱，要么是太过麻烦。</p><p>这个问题困扰我蛮久的，最近想到了一个办法，用软链接将大目录或文件链接到其它磁盘，来增加源磁盘空间。</p><p>操作很简单，大致思路如下</p><pre><code>* 复制srcPath到targetPath （复制的时候要加 -a 参数复制源目录的权限、组等信息）* 备份srcPath （保证万无一失）* 建立targetPath 软链接</code></pre><h2 id="3解决"><a class="markdownIt-Anchor" href="#3解决"></a> 3.解决</h2><p>为了方便管理，在挂载的<code>/ssd</code>下面创建<strong>root</strong>目录，以后<code>/ssd/root</code>将作为target目录做统一处理。</p><p>下面写了一个简单的shell，方便操作，使用办法<code>sh lnTool.sh -src=/usr/lib/xxx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sh lnTool.sh -src=/usr/lib/xxx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移动src到target并创建软链接,解决目前空间不足问题</span></span><br><span class="line"></span><br><span class="line">opts=$@</span><br><span class="line">getparam()&#123;</span><br><span class="line">arg=$1</span><br><span class="line">echo $opts | xargs -n1 | cut -b 2- | awk -F"=" '&#123;if($1=="'"$arg"'") print $2&#125;'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">src=$(getparam src)</span><br><span class="line">target=/ssd/root$src</span><br><span class="line"><span class="meta">#</span><span class="bash"> crete target dir</span></span><br><span class="line">sudo mkdir -p $target</span><br><span class="line"><span class="meta">#</span><span class="bash"> copy src to target</span></span><br><span class="line">sudo cp -a $src/* $target</span><br><span class="line"><span class="meta">#</span><span class="bash"> back src</span></span><br><span class="line">sudo mv $src $src.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> create soft link</span></span><br><span class="line">sudo ln -s $target $src</span><br></pre></td></tr></table></figure><p>比如,发现<code>/usr/share/doc</code>目录很大，使用shell完成建立软链接</p><p>直接运行 <code>sh lnTool.sh -src=/usr/share/doc</code>即可。</p><p>如果使用提供的<strong>shell</strong>的话，先<font color="red">做适当改动并拿几个文件试一下，以免出现问题。</font></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;本人使用Linux系统作为主系统，在装系统时，分区分的有些小，导致现在装点东西都很难办。&lt;/p&gt;&lt;h2 id=&quot;1操作系统&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Linux" scheme="yihao.ml/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="yihao.ml/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>NIO</title>
    <link href="yihao.ml/2020/09/24/2020%E2%80%9309-24-NIO%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>yihao.ml/2020/09/24/2020–09-24-NIO非阻塞IO/</id>
    <published>2020-09-24T01:59:52.000Z</published>
    <updated>2020-12-01T12:12:50.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>BIO(Blocking I/0) 为阻塞IO，NIO(Non-Blocking I/O)为非阻塞IO。</p><p>不推荐以BIO构建生产应用，它有以下特点</p><ol><li>阻塞式I/O</li><li>弹性伸缩能力差</li><li>多线程耗资源</li></ol><p>针对以上问题，NIO可以完美解决，下面为学习NIO，使用Java 原生API编写NIO聊天室，上生产的话参考封装NIO的Netty框架。</p><p>NioServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ml.yihao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java NIO编写聊天程序</span></span><br><span class="line"><span class="comment"> * 服务端程序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 20-9-24 下午11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer port = <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 构造注册中心selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建ServerSocketChannel 并绑定IP 和Port 设置为非阻塞模式</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(hostname, port));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用selector 的select方法检测就绪状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(select == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 拿到就绪集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 6. 根据channel类型处理业务逻辑</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 监听</span></span><br><span class="line">                    acceptHandler(serverSocketChannel, selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    readHandler(selectionKey , selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当监听到accept事件时，需要将socket注册到selector上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClosedChannelException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不设置这个东西会怎么样?</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        socketChannel.write(Charset.forName(ENCODING_UTF8).encode(<span class="string">"欢迎来到zyh搭建的聊天室！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听到读的事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel)selectionKey.channel();</span><br><span class="line">        <span class="comment">//socketChannel.read()</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(socketChannel.read(byteBuffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            result += Charset.forName(ENCODING_UTF8).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 广播数据</span></span><br><span class="line">            <span class="comment">//System.out.println(":: 读取的数据为" + result);</span></span><br><span class="line">            broadcast(selector, socketChannel, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 处理业务 是业务而定是否需要再次注册channel</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播数据给所有连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(Selector selector,SocketChannel sourceChannel, String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.keys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            SelectionKey selectionKey = iterator.next();</span><br><span class="line">            Channel targetChannel =  selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果targetChannel 是SocketChannel类型</span></span><br><span class="line">            <span class="comment">// 如果targetChannel 不是发消息的Channel</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel</span><br><span class="line">                        &amp;&amp; targetChannel != sourceChannel)&#123;</span><br><span class="line"></span><br><span class="line">                ((SocketChannel)targetChannel).write(Charset.forName(ENCODING_UTF8).encode(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NioServer server = <span class="keyword">new</span> NioServer();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ml.yihao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java NIO编写聊天程序</span></span><br><span class="line"><span class="comment"> * 客户端端程序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zyh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 20-9-25 上午0:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hostname = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer port = <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链接服务端</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.</span><br><span class="line">                open(<span class="keyword">new</span> InetSocketAddress(hostname, port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独开个线程接收服务端给的信息</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NioClient.ReadThread(selector)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务端写数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">            String line = scanner.next();</span><br><span class="line">            socketChannel.write(Charset.forName(ENCODING_UTF8).encode(line));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioClient nioClient = <span class="keyword">new</span> NioClient();</span><br><span class="line">        nioClient.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端读数据的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadThread</span><span class="params">(Selector selector)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 监测 注册中心channel就绪状态</span></span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(select == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 拿到selectionKey集合</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历判断channel类型</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 读取客户端中的数据</span></span><br><span class="line">                            readHanler(selectionKey, selector);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 不移除会导致set 中的对象堆积</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读取数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHanler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            String message = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(socketChannel.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                buffer.flip();</span><br><span class="line"></span><br><span class="line">                message += Charset.forName(ENCODING_UTF8).decode(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(message) &amp;&amp; message.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新注册Channel到selector上</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;BIO(Blocking I/0) 为阻塞IO，NIO(Non-Blocking I/O)为非阻塞IO。&lt;/p&gt;&lt;p&gt;不推荐以BIO构建生产应用，它有以下特
      
    
    </summary>
    
      <category term="后端" scheme="yihao.ml/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="NIO" scheme="yihao.ml/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Docker修改镜像存储位置</title>
    <link href="yihao.ml/2020/09/22/2020%E2%80%9309-22-docker%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8/"/>
    <id>yihao.ml/2020/09/22/2020–09-22-docker修改镜像存储/</id>
    <published>2020-09-22T00:21:52.000Z</published>
    <updated>2020-12-01T12:12:50.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>早期安装ubuntu+win双系统给ubuntu划分存储过小，导致现在不够用，使用下面配置修改Docker镜像存储目录。</p><p>Docker 默认镜像存储路径为 <code>/var/lib/docker</code>，下面修改位置并重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;],</span><br><span class="line">        &quot;graph&quot;: &quot;/media/zyh/SSD/root/var/lib/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改服务后发现拉完镜像无法启动，原因是<code>/media/zyh/SSD</code>这个磁盘格式是<code>HPFS/NTFS/exFAT</code></p><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案：</h3><p>将磁盘<code>/media/zyh/SSD</code>格式化为<code>ext4</code>格式，并挂载到<code>/</code>目录下即可</p><p>具体格式化磁盘的方法可以参考blog:<a href="https://www.cnblogs.com/bpdhpm/p/11384473.html" target="_blank" rel="noopener">https://www.cnblogs.com/bpdhpm/p/11384473.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;早期安装ubuntu+win双系统给ubuntu划分存储过小，导致现在不够用，使用下面配置修改Docker镜像存储目录。&lt;/p&gt;&lt;p&gt;Docker 默认镜像
      
    
    </summary>
    
      <category term="微服务" scheme="yihao.ml/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="问题总结" scheme="yihao.ml/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="yihao.ml/2020/09/19/2020%E2%80%9309-19-Docker/"/>
    <id>yihao.ml/2020/09/19/2020–09-19-Docker/</id>
    <published>2020-09-19T11:49:00.000Z</published>
    <updated>2020-12-01T12:12:50.359Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:59 GMT+0000 (GMT) --><p><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586333742105.png" alt="1586333742105"></p><blockquote><p>Author：Eric</p><p>Version：9.0.1</p><p>From : 转载</p></blockquote><p>看到Eric哥们在b站中分享的Docker视频，觉得讲的很好，这里提供一下讲义方便大家学习。</p><p>[TOC]</p><h3 id="一-引言"><a class="markdownIt-Anchor" href="#一-引言"></a> 一、引言</h3><hr><h4 id="11-环境不一致"><a class="markdownIt-Anchor" href="#11-环境不一致"></a> 1.1 环境不一致</h4><blockquote><p>我本地运行没问题啊：由于环境不一致，导致相同的程序，运行结果却不一致。</p></blockquote><h4 id="12-隔离性"><a class="markdownIt-Anchor" href="#12-隔离性"></a> 1.2 隔离性</h4><blockquote><p>哪个哥们又写死循环了，怎么这么卡：在多用户的操作系统下，会因为其他用户的操作失误影响到你自己编写的程序。</p></blockquote><h4 id="13-弹性伸缩"><a class="markdownIt-Anchor" href="#13-弹性伸缩"></a> 1.3 弹性伸缩</h4><blockquote><p>淘宝在双11，用户量暴增：需要很多很多的运维人员去增加部署的服务器，运维成本过高。</p></blockquote><h4 id="14-学习成本"><a class="markdownIt-Anchor" href="#14-学习成本"></a> 1.4 学习成本</h4><blockquote><p>学习一门技术，得先安装啊：学习每一门技术都要先安装响应的软件，但是还有他所依赖的各种环境，安装软件成本快高过学习成本啦。</p></blockquote><h3 id="二-docker介绍"><a class="markdownIt-Anchor" href="#二-docker介绍"></a> 二、Docker介绍</h3><hr><h4 id="21-docker的由来"><a class="markdownIt-Anchor" href="#21-docker的由来"></a> 2.1 Docker的由来</h4><blockquote><p>Docker 最初是 dotCloud 公司创始人Solomon Hykes 在法国期间发起的一个公司内部项目。</p><p>2010年的专门做PAAS平台，但是到了2013年的时候，像亚马逊，微软，Google都开始做PAAS平台。</p><p>到了2013年，公司资金链断裂，不得不倒闭，于是将公司内的核心技术对外开源，核心技术就是Docker。</p><p>由于开源了Docker，到了2014年的时候，得到了各轮融资，于是公司开始全神贯注的维护Docker。</p></blockquote><table><thead><tr><th style="text-align:center">Docker主要作者-Solomon</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586340594252.png" alt="1586340594252"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">现在Solomon已经离开了维护Docker的团队</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586340639934.png" alt="1586340639934"></td></tr></tbody></table><h4 id="22-docker的思想"><a class="markdownIt-Anchor" href="#22-docker的思想"></a> 2.2 Docker的思想</h4><blockquote><ul><li><p>封装：将需要的操作系统，环境，软件封装到一个镜像中。</p></li><li><p>标准化：</p><ul><li>运输的标准化：Docker提供了中央仓库，所有官方的镜像都放在了这个中央仓库中，当需要使用某一个镜像时，通过相应的方式拉取即可。</li><li>命令的标准化：Docker提供了一些列的命令，帮助我们去获取镜像，管理容器等等操作。</li><li>提供了REST的API：基于标准REST的API衍生出了很多的图形化界面，如Rancher等。</li></ul></li><li><p>隔离性：Docker在运行镜像时，会在Linux的内核中，单独的开辟一片空间，这片空间不会影响到其他程序。</p></li></ul></blockquote><h3 id="三-docker的安装"><a class="markdownIt-Anchor" href="#三-docker的安装"></a> 三、Docker的安装</h3><hr><h4 id="31-下载docker依赖的环境"><a class="markdownIt-Anchor" href="#31-下载docker依赖的环境"></a> 3.1 下载Docker依赖的环境</h4><blockquote><p>安装Docker，需要先将依赖的环境全部下载，就像Maven依赖JDK一样。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="32-指定docker镜像源"><a class="markdownIt-Anchor" href="#32-指定docker镜像源"></a> 3.2 指定Docker镜像源</h4><blockquote><p>默认情况下，下载Docker会从国外服务器下载，速度较慢，我们可以设置为阿里云镜像源，速度更快。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="33-安装docker"><a class="markdownIt-Anchor" href="#33-安装docker"></a> 3.3 安装Docker</h4><blockquote><p>采用yum的方式安装。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>Docker 安装不了可能是源的问题,我的机器是ubuntu，这里参考了链接完成了安装https://www.runoob.com/docker/ubuntu-docker-install.html</p><h4 id="34-启动docker并测试"><a class="markdownIt-Anchor" href="#34-启动docker并测试"></a> 3.4 启动Docker并测试</h4><blockquote><p>安装成功后，需要手动启动，设置为开机自启，并测试。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="四-docker的中央仓库重点"><a class="markdownIt-Anchor" href="#四-docker的中央仓库重点"></a> 四、Docker的中央仓库【<code>重点</code>】</h3><hr><blockquote><ul><li><p>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。</p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p></li><li><p>国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。</p><p><a href="https://c.163yun.com/hub#/home" target="_blank" rel="noopener">https://c.163yun.com/hub#/home</a></p><p><a href="http://hub.daocloud.io/" target="_blank" rel="noopener">http://hub.daocloud.io/</a> （推荐使用）</p></li><li><p>在公司内部会采用私服的方式拉取镜像，需要添加配置，如下……</p></li></ul></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 需要创建或修改/etc/docker/daemon.json，并添加如下内容，"ip:port"可以编写多个。</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line"><span class="attr">"insecure-registries"</span>: [<span class="string">"ip:port"</span>]   </span><br><span class="line">&#125;</span><br><span class="line"># 重启docker服务</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="五-镜像的操作"><a class="markdownIt-Anchor" href="#五-镜像的操作"></a> 五、镜像的操作</h3><hr><h4 id="51-拉取镜像"><a class="markdownIt-Anchor" href="#51-拉取镜像"></a> 5.1 拉取镜像</h4><blockquote><p>从中央仓库拉取镜像到本地</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个栗子：docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></span><br></pre></td></tr></table></figure><h4 id="52-查看本地全部镜像"><a class="markdownIt-Anchor" href="#52-查看本地全部镜像"></a> 5.2 查看本地全部镜像</h4><blockquote><p>查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h4 id="53-删除本地镜像"><a class="markdownIt-Anchor" href="#53-删除本地镜像"></a> 5.3 删除本地镜像</h4><blockquote><p>镜像会占用磁盘空间，可以直接手动删除，表示通过查看获取</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像的标识 | 镜像名称:tag</span><br><span class="line">docker rmi b8dfe9ade316</span><br><span class="line">docker rmi daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><h4 id="54-镜像的导入导出"><a class="markdownIt-Anchor" href="#54-镜像的导入导出"></a> 5.4 镜像的导入导出</h4><blockquote><ul><li>如果出现网络故障，可以采过硬盘的方式传输镜像，虽然不规范，但是有效。</li><li>但是这种方式导出的镜像名称和版本都是null，需要手动修改</li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line">doeker save -o /usr/<span class="built_in">local</span>/abc.tar b8dfe9ade316</span><br><span class="line"><span class="comment"># 加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line">docker load -i /usr/<span class="built_in">local</span>/abc.tar</span><br><span class="line"><span class="comment"># 修改镜像名称</span></span><br><span class="line">docker tag 镜像id 新镜像名称:版本</span><br><span class="line">docker tag b8dfe9ade316  mytomcat:1.0</span><br></pre></td></tr></table></figure><h3 id="六-容器操作重点"><a class="markdownIt-Anchor" href="#六-容器操作重点"></a> 六、容器操作【<code>重点</code>】</h3><hr><h4 id="61-运行容器"><a class="markdownIt-Anchor" href="#61-运行容器"></a> 6.1 运行容器</h4><blockquote><p>运行容器需要指定具体镜像，如果镜像不存在，会直接下载</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单操作</span></span><br><span class="line">docker run 镜像的标识 | 镜像名称[:tag]</span><br><span class="line">docker run b8dfe9ade316</span><br><span class="line">docker run daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line"><span class="comment"># 常用的参数</span></span><br><span class="line">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span><br><span class="line">docker run -d -p 8090:8080 --name my_container b8dfe9ade316</span><br><span class="line"><span class="comment"># -d：代表后台运行容器</span></span><br><span class="line"><span class="comment"># -p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span></span><br><span class="line"><span class="comment"># --name 容器名称：指定容器的名称</span></span><br></pre></td></tr></table></figure><h4 id="62-查看正在运行的容器"><a class="markdownIt-Anchor" href="#62-查看正在运行的容器"></a> 6.2 查看正在运行的容器</h4><blockquote><p>查看全部正在运行的容器信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps [-qa]</span><br><span class="line"><span class="comment"># -a：查看全部的容器，包括没有运行</span></span><br><span class="line"><span class="comment"># -q：只查看容器的标识</span></span><br></pre></td></tr></table></figure><h4 id="63-查看容器日志"><a class="markdownIt-Anchor" href="#63-查看容器日志"></a> 6.3 查看容器日志</h4><blockquote><p>查看容器日志，以查看容器运行的信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器id</span><br><span class="line"><span class="comment"># -f：可以滚动查看日志的最后几行</span></span><br></pre></td></tr></table></figure><h4 id="64-进入容器内容部"><a class="markdownIt-Anchor" href="#64-进入容器内容部"></a> 6.4 进入容器内容部</h4><blockquote><p>可以进入容器内部进行操作</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器id bash</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称 bash</span><br></pre></td></tr></table></figure><h4 id="65-复制内容到容器"><a class="markdownIt-Anchor" href="#65-复制内容到容器"></a> 6.5 复制内容到容器</h4><blockquote><p>将宿主机的文件复制到容器内部的指定目录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br></pre></td></tr></table></figure><h4 id="66-重启启动停止删除容器"><a class="markdownIt-Anchor" href="#66-重启启动停止删除容器"></a> 6.6 重启&amp;启动&amp;停止&amp;删除容器</h4><blockquote><p>容器的启动，停止，删除等操作，后续经常会使用到</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动停止运行的容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器（删除容器前，需要先停止容器）</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="comment"># 停止全部容器</span></span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="comment"># 删除全部容器</span></span><br><span class="line">docker rm $(docker ps -qa)</span><br></pre></td></tr></table></figure><h3 id="七-docker应用"><a class="markdownIt-Anchor" href="#七-docker应用"></a> 七、Docker应用</h3><hr><h4 id="71-docker安装tomcat"><a class="markdownIt-Anchor" href="#71-docker安装tomcat"></a> 7.1 Docker安装Tomcat</h4><blockquote><p>运行Tomcat容器，为部署SSM工程做准备</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name tomcat daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><h4 id="72-docker安装mysql"><a class="markdownIt-Anchor" href="#72-docker安装mysql"></a> 7.2 Docker安装MySQL</h4><blockquote><p>运行MySQL容器，为部署SSM工程做准备</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3366:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 宿主机中通过 3366连接 容器中的mysql</span></span><br><span class="line">[root@localhost logs]<span class="comment"># mysql -uroot -P 3366 -proot -h 192.168.1.135</span></span><br></pre></td></tr></table></figure><h4 id="73-部署ssm工程"><a class="markdownIt-Anchor" href="#73-部署ssm工程"></a> 7.3 部署SSM工程</h4><blockquote><ul><li>修改SSM工程环境，设置为Linux中Docker容器的信息</li><li>通过Maven的package重新打成war包</li><li>将Windows下的war包复制到Linux中</li><li>通过docker命令将宿主机的war包复制到容器内部</li><li>测试访问SSM工程</li></ul></blockquote><h3 id="八-数据卷重点"><a class="markdownIt-Anchor" href="#八-数据卷重点"></a> 八、数据卷【<code>重点</code>】</h3><hr><blockquote><ul><li><p>为部署SSM的工程，需要使用到Docker的cp命令将宿主机内的ssm.war文件复制到容器内部，操作麻烦。</p></li><li><p><a href>数据卷</a>：</p></li><li><p>将宿主机的一个目录映射到容器的一个目录中。</p></li><li><p>可以在宿主机中操作目录中的内容，容器内部映射的文件会跟着一起改变。</p></li></ul></blockquote><h4 id="81-创建数据卷"><a class="markdownIt-Anchor" href="#81-创建数据卷"></a> 8.1 创建数据卷</h4><blockquote><p>创建数据卷之后，默认会存放在一个目录下 /var/lib/docker/volumes/数据卷名称/_data</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="82-查看数据卷详情"><a class="markdownIt-Anchor" href="#82-查看数据卷详情"></a> 8.2 查看数据卷详情</h4><blockquote><p>查看数据卷的详细信息，可以查询到存放路径，创建时间等等</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="83-查看全部数据卷"><a class="markdownIt-Anchor" href="#83-查看全部数据卷"></a> 8.3 查看全部数据卷</h4><blockquote><p>查看全部数据卷信息</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h4 id="84-删除数据卷"><a class="markdownIt-Anchor" href="#84-删除数据卷"></a> 8.4 删除数据卷</h4><blockquote><p>删除指定数据卷</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm 数据卷名称</span><br></pre></td></tr></table></figure><h4 id="85-容器映射数据卷"><a class="markdownIt-Anchor" href="#85-容器映射数据卷"></a> 8.5 容器映射数据卷</h4><blockquote><p>映射有两种方式：</p><ul><li>通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</li><li>通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过数据卷名称映射</span></span><br><span class="line">docker run -v 数据卷名称:容器内部的路径 镜像id</span><br><span class="line">docker run -v webapps2004:/usr/<span class="built_in">local</span>/tomcat/webappss 镜像id</span><br><span class="line"><span class="comment"># 通过路径映射数据卷</span></span><br><span class="line">docker run -v 路径:容器内部的路径 镜像id</span><br><span class="line">docker run -v /usr/<span class="built_in">local</span>/tomcat_webapps2004:/usr/<span class="built_in">local</span>/tomcat/webapps 镜像id</span><br></pre></td></tr></table></figure><h3 id="九-dockerfile自定义镜像重点"><a class="markdownIt-Anchor" href="#九-dockerfile自定义镜像重点"></a> 九、Dockerfile自定义镜像【<code>重点</code>】</h3><hr><blockquote><p>我们可以从中央仓库下载一个镜像，也可以自己手动去制作一个镜像，需要通过Dockerfile去指定自定义镜像的信息</p></blockquote><h4 id="91-dockerfile"><a class="markdownIt-Anchor" href="#91-dockerfile"></a> 9.1 Dockerfile</h4><blockquote><p>创建自定义镜像就需要创建一个Dockerfile，如下为Dockerfile的常用配置</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from: 指定当前自定义镜像依赖的环境</span><br><span class="line">copy: 将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir: 声明镜像的默认工作目录</span><br><span class="line">run: 执行的命令，可以编写多个</span><br><span class="line">cmd: 需要执行的命令（在workdir下执行的，cmd可以写多个，但是只以最后一个为准）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个例子，制作SSM容器镜像，而且ssm.war要放在Dockerfile的同级目录下</span></span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure><h4 id="92-通过dockerfile制作镜像"><a class="markdownIt-Anchor" href="#92-通过dockerfile制作镜像"></a> 9.2 通过Dockerfile制作镜像</h4><blockquote><p>编写完Dockerfile后需要Dockerfile所在目录通过命令将其制作为镜像，注意最后的 <a href>.</a> 代表当前目录。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:tag] .</span><br></pre></td></tr></table></figure><h3 id="十-docker-compose重点"><a class="markdownIt-Anchor" href="#十-docker-compose重点"></a> 十. Docker-Compose【<code>重点</code>】</h3><hr><blockquote><ul><li>运行一个容器，我们需要添加大量的参数，可以通过Docker-Compose文件配置参数。</li><li>参数信息通过docker-compose.yml文件去维护。</li><li>Docker-Compose可以批量管理容器。</li></ul></blockquote><h4 id="101-下载并安装docker-compose"><a class="markdownIt-Anchor" href="#101-下载并安装docker-compose"></a> 10.1 下载并安装Docker-Compose</h4><h5 id="1011-下载docker-compose"><a class="markdownIt-Anchor" href="#1011-下载docker-compose"></a> 10.1.1 下载Docker-Compose</h5><blockquote><p>去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</p><p>下载路径：<a href>https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</a></p></blockquote><h5 id="1012-设置权限"><a class="markdownIt-Anchor" href="#1012-设置权限"></a> 10.1.2 设置权限</h5><blockquote><p>需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br></pre></td></tr></table></figure><h5 id="1013-移动到usrlocalbin目录下"><a class="markdownIt-Anchor" href="#1013-移动到usrlocalbin目录下"></a> 10.1.3 移动到/usr/local/bin目录下</h5><blockquote><p>方便后期操作，将docker-compose文件移动到了/usr/local/bin</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv docker-compose /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><h5 id="1014-测试"><a class="markdownIt-Anchor" href="#1014-测试"></a> 10.1.4 测试</h5><blockquote><p>在任意目录下输入docker-compose</p></blockquote><table><thead><tr><th style="text-align:center">测试效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1586420176720.png" alt="1586420176720"></td></tr></tbody></table><h4 id="102-docker-compose管理mysql和tomcat容器"><a class="markdownIt-Anchor" href="#102-docker-compose管理mysql和tomcat容器"></a> 10.2 Docker-Compose管理MySQL和Tomcat容器</h4><blockquote><ul><li><p>yml文件以key: value方式来指定配置信息</p></li><li><p>多个配置信息以换行+缩进的方式来区分</p></li><li><p>在docker-compose.yml文件中，不要使用制表符</p></li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql:</span>           <span class="comment"># 服务的名称</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span>   <span class="comment"># 代表只要docker启动，那么这个容器就跟着一起启动</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">daocloud.io/library/mysql:5.7.4</span>  <span class="comment"># 指定镜像路径</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">mysql</span>  <span class="comment"># 指定容器名称</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">3306</span><span class="string">:3306</span>   <span class="comment">#  指定端口号的映射</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span>   <span class="comment"># 指定MySQL的ROOT用户登录密码</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span>        <span class="comment"># 指定时区</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql</span>   <span class="comment"># 映射数据卷</span></span><br><span class="line"><span class="attr">  tomcat:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span></span><br></pre></td></tr></table></figure><h4 id="103-使用docker-compose命令管理容器"><a class="markdownIt-Anchor" href="#103-使用docker-compose命令管理容器"></a> 10.3 使用docker-compose命令管理容器</h4><blockquote><p>在docker-compose.yml文件目录下使用docker-compose的命令时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于docker-compose.yml启动管理的容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 关闭并删除容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 开启|关闭|重启已经存在的由docker-compose维护的容器</span></span><br><span class="line">docker-compose start|stop|restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看由docker-compose管理的容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 查看日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h4 id="104-docker-compose配合dockerfile使用"><a class="markdownIt-Anchor" href="#104-docker-compose配合dockerfile使用"></a> 10.4 docker-compose配合Dockerfile使用</h4><blockquote><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器</p></blockquote><h5 id="1041-docker-compose文件"><a class="markdownIt-Anchor" href="#1041-docker-compose文件"></a> 10.4.1 docker-compose文件</h5><blockquote><p>编写docker-compose.yml文件</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  ssm:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    build:</span>            <span class="comment"># 构建自定义镜像</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">../</span>      <span class="comment"># 指定dockerfile文件的所在路径</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile</span>   <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">ssm:1.0.1</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">ssm</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8081</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h5 id="1042-dockerfile文件"><a class="markdownIt-Anchor" href="#1042-dockerfile文件"></a> 10.4.2 Dockerfile文件</h5><blockquote><p>编写Dockerfile文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h5 id="1043-运行"><a class="markdownIt-Anchor" href="#1043-运行"></a> 10.4.3 运行</h5><blockquote><p>测试效果</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建自定义镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行当前内容，并重新构建</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><h3 id="十一-docker-ci-cd"><a class="markdownIt-Anchor" href="#十一-docker-ci-cd"></a> 十一. Docker CI、CD</h3><hr><h4 id="111-ci-cd引言"><a class="markdownIt-Anchor" href="#111-ci-cd引言"></a> 11.1 CI、CD引言</h4><blockquote><p>项目部署</p><ul><li>将项目通过maven进行编译打包</li><li>将文件上传到指定的服务器中</li><li>将war包放到tomcat的目录中</li><li>通过Dockerfile将Tomcat和war包转成一个镜像，由DockerCompose去运行容器</li></ul><p>项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过CI、CD帮助我们实现持续集成，持续交付和部署。</p></blockquote><h4 id="112-ci介绍"><a class="markdownIt-Anchor" href="#112-ci介绍"></a> 11.2 CI介绍</h4><blockquote><p>CI（continuous intergration）持续集成</p><p>持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试。</p><ul><li>快速发现错误。</li><li>防止代码偏离主分支。</li></ul></blockquote><h4 id="113-搭建gitlab服务器"><a class="markdownIt-Anchor" href="#113-搭建gitlab服务器"></a> 11.3 搭建Gitlab服务器</h4><blockquote><p>实现CI，需要使用到Gitlab远程仓库，先通过Docker搭建Gitlab</p></blockquote><h5 id="1131-准备工作"><a class="markdownIt-Anchor" href="#1131-准备工作"></a> 11.3.1 准备工作</h5><blockquote><ul><li>创建一个全新的虚拟机，并且至少指定4G的运行内存，4G运行内存是Gitlab推荐的内存大小。</li><li>并且安装Docker以及Docker-Compose</li></ul></blockquote><h5 id="1132-修改ssh的22端口"><a class="markdownIt-Anchor" href="#1132-修改ssh的22端口"></a> 11.3.2 修改ssh的22端口</h5><blockquote><p>将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">  PORT 22 -&gt; 60022</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h5 id="1133-编写docker-composeyml"><a class="markdownIt-Anchor" href="#1133-编写docker-composeyml"></a> 11.3.3 编写docker-compose.yml</h5><blockquote><p>docker-compose.yml文件去安装gitlab（下载和运行的时间比较长的）</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr"> gitlab:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">'twang2218/gitlab-ce-zh:11.1.4'</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">"gitlab"</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  hostname:</span> <span class="string">'gitlab'</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">   TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line"><span class="attr">   GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    external_url 'http://192.168.199.110'</span></span><br><span class="line"><span class="string">    gitlab_rails['time_zone'] = 'Asia/Shanghai'</span></span><br><span class="line"><span class="string">    gitlab_rails['smtp_enable'] = true</span></span><br><span class="line"><span class="string">    gitlab_rails['gitlab_shell_ssh_port'] = 22</span></span><br><span class="line"><span class="string"></span><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'80:80'</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'443:443'</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">'22:22'</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/config:/etc/gitlab</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/data:/var/opt/gitlab</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/opt/docker_gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h4 id="114-搭建gitlabrunner"><a class="markdownIt-Anchor" href="#114-搭建gitlabrunner"></a> 11.4 搭建GitlabRunner</h4><h5 id="1141-配置私服信息"><a class="markdownIt-Anchor" href="#1141-配置私服信息"></a> 11.4.1 配置私服信息</h5><blockquote><p>创建或修改/etc/docker/daemon.json，并添加如下内容。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"baseservice.qfjava.cn:60001"</span> </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重启两个服务</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h5 id="1142-添加docker-composeyml文件"><a class="markdownIt-Anchor" href="#1142-添加docker-composeyml文件"></a> 11.4.2 添加docker-compose.yml文件</h5><blockquote><ul><li>创建工作目录 /opt/docker_gitlab-runner</li><li>在 /opt/docker_gitlab-runner添加docker-compose.yml文件</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  gitlab-runner:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">environment</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">gitlab-runner</span></span><br><span class="line"><span class="attr">    privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./config:/etc/gitlab-runner</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><h5 id="1143-在yml文件目录添加环境目录"><a class="markdownIt-Anchor" href="#1143-在yml文件目录添加环境目录"></a> 11.4.3 在yml文件目录添加环境目录</h5><blockquote><p>创建environment目录，在目录中逐个添加各个配置及软件</p></blockquote><blockquote><p>Dockerfile</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">FROM baseservice.qfjava.cn:60001/gitlab-runner:bleeding</span><br><span class="line"># 修改软件源</span><br><span class="line">RUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&apos; &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    #下面的地址需要根据实际情况变化</span><br><span class="line">    wget https://http.kali.org/kali/pool/main/k/kali-archive-keyring/kali-archive-keyring_2018.2_all.deb --no-check-certificate &amp;&amp; \</span><br><span class="line">    apt install -y ./kali-archive-keyring_2018.2_all.deb &amp;&amp; \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt install -y  gnupg  &amp;&amp; \</span><br><span class="line">    apt-get clean</span><br><span class="line"></span><br><span class="line"># 安装 Docker</span><br><span class="line">RUN curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - &amp;&amp; \</span><br><span class="line">    apt-get install -y python-software-properties software-properties-common &amp;&amp; \</span><br><span class="line">    echo &apos;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&apos; &gt;&gt; /etc/apt/sources.list.d/docker.list &amp;&amp; \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y docker-ce</span><br><span class="line"></span><br><span class="line">COPY daemon.json /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"># 安装 Docker Compose,因为下载不下来，所以我们本地上传一份docker-compose到environment目录</span><br><span class="line">WORKDIR /usr/local/bin</span><br><span class="line">#RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose</span><br><span class="line">COPY docker-compose docker-compose</span><br><span class="line">RUN chmod +x docker-compose</span><br><span class="line"></span><br><span class="line"># 安装 Java</span><br><span class="line">RUN mkdir -p /usr/local/java</span><br><span class="line">WORKDIR /usr/local/java</span><br><span class="line">COPY jdk-8u231-linux-x64.tar.gz /usr/local/java</span><br><span class="line">RUN tar -zxvf jdk-8u231-linux-x64.tar.gz &amp;&amp; \</span><br><span class="line">    rm -fr jdk-8u231-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># 安装 Maven</span><br><span class="line">RUN mkdir -p /usr/local/maven</span><br><span class="line">WORKDIR /usr/local/maven</span><br><span class="line"># RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">COPY apache-maven-3.6.3-bin.tar.gz /usr/local/maven</span><br><span class="line">RUN tar -zxvf apache-maven-3.6.3-bin.tar.gz &amp;&amp; \</span><br><span class="line">    rm -fr apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">#需要配置maven 私服的话,不需要就加#注释掉</span><br><span class="line">#COPY settings.xml /usr/local/maven/apache-maven-3.6.3/conf/settings.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_231</span><br><span class="line">ENV MAVEN_HOME /usr/local/maven/apache-maven-3.6.3</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /</span><br></pre></td></tr></table></figure><blockquote><p>daemon.json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;: [</span><br><span class="line">    &quot;baseservice.qfjava.cn:60001&quot; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>docker-compose可执行文件。</p></blockquote><blockquote><p><a href>apache-maven-3.6.3-bin.tar.gz</a>，以及<a href>jdk-8u231-linux-x64.tar.gz</a>压缩包文件。</p></blockquote><h5 id="1144-设置docker权限"><a class="markdownIt-Anchor" href="#1144-设置docker权限"></a> 11.4.4 设置Docker权限</h5><blockquote><ul><li>在宿主机启动docker程序后先执行 <a href>sudo chown root:root /var/run/docker.sock</a>。</li><li>在<a href>/opt/docker_gitlab-runner</a>目录中执行<a href>docker-compose up -d --build</a>启动容器。</li><li>启动容器成功后，添加容器权限，保证容器可以使用宿主机的docker：<a href>docker exec -it gitlab-runner usermod -aG root gitlab-runner</a></li></ul></blockquote><h5 id="1145-注册runner信息到gitlab"><a class="markdownIt-Anchor" href="#1145-注册runner信息到gitlab"></a> 11.4.5 注册Runner信息到gitlab</h5><blockquote><p>注册信息整个过程</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab-runner gitlab-runner register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 GitLab 地址</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):</span><br><span class="line">http://192.168.199.109/  <span class="comment"># 根据gitlab地址添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 GitLab Token</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner:</span><br><span class="line">1Lxq_f1NRfCfeNbE5WRh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 Runner 的说明</span></span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner:</span><br><span class="line">可以为空</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span></span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里选择 true ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to run untagged builds [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里选择 false，可以直接回车，默认为 false（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to lock Runner to current project [<span class="literal">true</span>/<span class="literal">false</span>]:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 runner 执行器，这里我们选择的是 shell</span></span><br><span class="line">Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h4 id="115-整合项目入门测试"><a class="markdownIt-Anchor" href="#115-整合项目入门测试"></a> 11.5 整合项目入门测试</h4><h5 id="1151-创建项目"><a class="markdownIt-Anchor" href="#1151-创建项目"></a> 11.5.1 创建项目</h5><blockquote><p>创建maven工程，添加web.xml文件，编写html页面</p></blockquote><h5 id="1152-编写gitlab-ciyml"><a class="markdownIt-Anchor" href="#1152-编写gitlab-ciyml"></a> 11.5.2 编写.gitlab-ci.yml</h5><blockquote><p>编写<a href>.gitlab-ci.yml</a>文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo first test ci   # 测试回声命令，测试效果</span><br></pre></td></tr></table></figure><h5 id="1153-将maven工程推送到gitlab中"><a class="markdownIt-Anchor" href="#1153-将maven工程推送到gitlab中"></a> 11.5.3 将maven工程推送到gitlab中</h5><blockquote><p>执行git命令推送到Gitlab</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h5 id="1154-查看效果"><a class="markdownIt-Anchor" href="#1154-查看效果"></a> 11.5.4 查看效果</h5><blockquote><p>可以在gitlab中查看到gitlab-ci.yml编写的内容</p></blockquote><table><thead><tr><th style="text-align:center">效果图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588671760385.png" alt="1588671760385"></td></tr></tbody></table><h4 id="116-完善项目配置"><a class="markdownIt-Anchor" href="#116-完善项目配置"></a> 11.6 完善项目配置</h4><blockquote><p>添加Dockerfile以及docker-compose.yml， 并修改<a href>.gitlab-ci.yml</a>文件</p></blockquote><h5 id="1161-创建dockerfile"><a class="markdownIt-Anchor" href="#1161-创建dockerfile"></a> 11.6.1 创建Dockerfile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfile</span><br><span class="line">FROM daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">COPY testci.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h5 id="1162-创建docker-composeyml"><a class="markdownIt-Anchor" href="#1162-创建docker-composeyml"></a> 11.6.2 创建docker-compose.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  testci:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">testci</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h5 id="1163-修改gitlab-ciyml"><a class="markdownIt-Anchor" href="#1163-修改gitlab-ciyml"></a> 11.6.3 修改.gitlab-ci.yml</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ci.yml</span><br><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo first test ci</span><br><span class="line">    - /usr/local/maven/apache-maven-3.6.3/bin/mvn package</span><br><span class="line">    - cp target/testci-1.0-SNAPSHOT.war docker/testci.war</span><br><span class="line">    - docker-compose down</span><br><span class="line">    - docker-compose up -d --build</span><br><span class="line">    - docker rmi $(docker images -qf dangling=true)</span><br></pre></td></tr></table></figure><h5 id="1164-测试"><a class="markdownIt-Anchor" href="#1164-测试"></a> 11.6.4 测试</h5><table><thead><tr><th style="text-align:center">测试效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588674040060.png" alt="1588674040060"></td></tr></tbody></table><h4 id="117-cd介绍"><a class="markdownIt-Anchor" href="#117-cd介绍"></a> 11.7 CD介绍</h4><blockquote><p>CD（持续交付，持续部署）</p><p>持续交付：将代码交付给专业的测试团队去测试</p><p>持续部署：可以直接将指定好tag的代码直接部署到生产环境中</p></blockquote><table><thead><tr><th style="text-align:center">CICD图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588677492583.png" alt="1588677492583"></td></tr></tbody></table><h4 id="118-安装jenkins"><a class="markdownIt-Anchor" href="#118-安装jenkins"></a> 11.8 安装Jenkins</h4><h5 id="1181-编写docker-composeyml"><a class="markdownIt-Anchor" href="#1181-编写docker-composeyml"></a> 11.8.1 编写docker-compose.yml</h5><blockquote><p>官网：<a href="https://www.jenkins.io/" target="_blank" rel="noopener">https://www.jenkins.io/</a></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">   image:</span> <span class="string">jenkins/jenkins</span></span><br><span class="line"><span class="attr">   restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">   container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">   ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="number">8888</span><span class="string">:8080</span></span><br><span class="line"><span class="bullet">     -</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line"><span class="attr">   volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">./data:/var/jenkins_home</span></span><br></pre></td></tr></table></figure><h5 id="1182-运行并访问jenkins"><a class="markdownIt-Anchor" href="#1182-运行并访问jenkins"></a> 11.8.2 运行并访问Jenkins</h5><blockquote><p>第一次运行时，会因为data目录没有权限，导致启动失败</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 data</span><br></pre></td></tr></table></figure><blockquote><p>访问http://192.168.199.109:8888</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问速度奇慢无比。。。。。</span><br></pre></td></tr></table></figure><blockquote><p>访问成功后，需要输入密码，可在日志中查看</p></blockquote><table><thead><tr><th>查看日志,以及Jenkins页面</th></tr></thead><tbody><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232643961.png" alt="image-20200708232643961"></td></tr><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232614918.png" alt="image-20200708232614918"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">选择安装插件方式</th></tr></thead><tbody><tr><td style="text-align:center">手动选择插件.</td></tr></tbody></table><blockquote><p>查看需要实现安装<a href>Publish Over SSH</a> 以及 <a href>Git Parameter</a></p></blockquote><table><thead><tr><th style="text-align:center">安装插件</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232754318.png" alt="image-20200708232754318"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232800931.png" alt="image-20200708232800931"></td></tr></tbody></table><blockquote><p>安装成功后，需要指定上用户名和密码等信息</p></blockquote><table><thead><tr><th style="text-align:center">指定用户名密码信息</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232842803.png" alt="image-20200708232842803"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232910197.png" alt="image-20200708232910197"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708232922638.png" alt="image-20200708232922638"></td></tr></tbody></table><blockquote><p>登陆成功</p></blockquote><table><thead><tr><th style="text-align:center">登录成功</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681196639.png" alt="1588681196639"></td></tr></tbody></table><blockquote><p>登录成功后,还需要单独安装<a href>Persistent Parameter</a>插件</p></blockquote><table><thead><tr><th style="text-align:center">安装方式及安装成功图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708233023116.png" alt="image-20200708233023116"></td></tr><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/image-20200708233031967.png" alt="image-20200708233031967"></td></tr></tbody></table><h4 id="119-配置jenkins的目标服务器"><a class="markdownIt-Anchor" href="#119-配置jenkins的目标服务器"></a> 11.9 配置Jenkins的目标服务器</h4><blockquote><p>执行过程：代码提交到Gitlab，Jenkins会从Gitlab中拉取代码，并在Jenkins中打包并发布到目标服务器中。</p></blockquote><h5 id="1191-点击左侧的系统设置"><a class="markdownIt-Anchor" href="#1191-点击左侧的系统设置"></a> 11.9.1 点击左侧的系统设置</h5><table><thead><tr><th style="text-align:center">左侧导航</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681954779.png" alt="1588681954779"></td></tr></tbody></table><h5 id="1192-选中中间区域的系统设置"><a class="markdownIt-Anchor" href="#1192-选中中间区域的系统设置"></a> 11.9.2 选中中间区域的系统设置</h5><table><thead><tr><th style="text-align:center">系统设置</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588681970621.png" alt="1588681970621"></td></tr></tbody></table><h5 id="1193-搜索publish-over-ssh"><a class="markdownIt-Anchor" href="#1193-搜索publish-over-ssh"></a> 11.9.3 搜索Publish over SSH</h5><table><thead><tr><th style="text-align:center">Publish over SSH</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588682011820.png" alt="1588682011820"></td></tr></tbody></table><h5 id="1194-点击上图新增"><a class="markdownIt-Anchor" href="#1194-点击上图新增"></a> 11.9.4 点击上图新增</h5><table><thead><tr><th>新增SSH连接</th></tr></thead><tbody><tr><td><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588682092002.png" alt="1588682092002"></td></tr></tbody></table><h4 id="1110-配置gitlab免密码登录"><a class="markdownIt-Anchor" href="#1110-配置gitlab免密码登录"></a> 11.10 配置GitLab免密码登录</h4><blockquote><p>链接Gitlab需要使用密码，我们可以通过SSH的方式，免密码登陆Gitlab拉取代码，避免每次都输入密码。</p></blockquote><h5 id="11101登录jenkins容器内部"><a class="markdownIt-Anchor" href="#11101登录jenkins容器内部"></a> 11.10.1登录Jenkins容器内部</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jenkins bash</span><br></pre></td></tr></table></figure><h5 id="11102-输入生成ssh秘钥命令"><a class="markdownIt-Anchor" href="#11102-输入生成ssh秘钥命令"></a> 11.10.2 输入生成SSH秘钥命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱（随便写）&quot;</span><br></pre></td></tr></table></figure><h5 id="11103将秘钥复制到gitlab的ssh中"><a class="markdownIt-Anchor" href="#11103将秘钥复制到gitlab的ssh中"></a> 11.10.3将秘钥复制到GitLab的SSH中</h5><table><thead><tr><th style="text-align:center">配置密钥</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588683585249.png" alt="1588683585249"></td></tr></tbody></table><h4 id="1111-配置jdk和maven"><a class="markdownIt-Anchor" href="#1111-配置jdk和maven"></a> 11.11 配置JDK和Maven</h4><blockquote><p>我们需要再Jenkins中将代码打包，需要依赖JDK和Maven的环境</p></blockquote><h5 id="11111-复制软件到data目录下"><a class="markdownIt-Anchor" href="#11111-复制软件到data目录下"></a> 11.11.1 复制软件到data目录下</h5><table><thead><tr><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588684490466.png" alt="1588684490466"></td></tr></tbody></table><h5 id="11112-在监控界面中配置jdk和maven"><a class="markdownIt-Anchor" href="#11112-在监控界面中配置jdk和maven"></a> 11.11.2 在监控界面中配置JDK和Maven</h5><table><thead><tr><th style="text-align:center">配置环境变量</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588684458028.png" alt="1588684458028"></td></tr></tbody></table><h5 id="11113-手动拉取gitlab项目"><a class="markdownIt-Anchor" href="#11113-手动拉取gitlab项目"></a> 11.11.3 手动拉取gitlab项目</h5><blockquote><p>使用SSH无密码连接时，第一次连接需要手动确定</p></blockquote><table><thead><tr><th style="text-align:center">手动拉取一次</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588685220324.png" alt="1588685220324"></td></tr></tbody></table><h4 id="1112-创建maven任务"><a class="markdownIt-Anchor" href="#1112-创建maven任务"></a> 11.12 创建maven任务</h4><blockquote><p>实现通过Jenkins的Maven任务，自动去Gitlab拉取代码，并在本地打包，发布到目标服务器上</p></blockquote><h5 id="11121-创建maven工程推送到gitlab中"><a class="markdownIt-Anchor" href="#11121-创建maven工程推送到gitlab中"></a> 11.12.1 创建maven工程，推送到GitLab中</h5><blockquote><p>随便创建一个即可……</p></blockquote><h5 id="11122-jenkins的监控页面中创建maven任务"><a class="markdownIt-Anchor" href="#11122-jenkins的监控页面中创建maven任务"></a> 11.12.2 Jenkins的监控页面中创建maven任务</h5><table><thead><tr><th style="text-align:center">指定GitLab地址</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686481506.png" alt="1588686481506"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">指定maven打包方式</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686489821.png" alt="1588686489821"></td></tr></tbody></table><h5 id="11123-执行maven任务"><a class="markdownIt-Anchor" href="#11123-执行maven任务"></a> 11.12.3 执行maven任务</h5><table><thead><tr><th style="text-align:center">立即构建，并查看日志</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686591351.png" alt="1588686591351"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">控制台查看日志信息</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588686553880.png" alt="1588686553880"></td></tr></tbody></table><h5 id="11124-最终效果"><a class="markdownIt-Anchor" href="#11124-最终效果"></a> 11.12.4 最终效果</h5><table><thead><tr><th style="text-align:center">打包成功</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588687382594.png" alt="1588687382594"></td></tr></tbody></table><h4 id="1113-实现持续交付持续部署"><a class="markdownIt-Anchor" href="#1113-实现持续交付持续部署"></a> 11.13 实现持续交付持续部署</h4><blockquote><p>实现根据tag标签，实现持续交付和持续部署</p></blockquote><h5 id="11131-安装persistent-parameter的插件"><a class="markdownIt-Anchor" href="#11131-安装persistent-parameter的插件"></a> 11.13.1 安装Persistent Parameter的插件</h5><table><thead><tr><th style="text-align:center">安装插件</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588693533099.png" alt="1588693533099"></td></tr></tbody></table><h5 id="11132-重新指定构建项目的方式"><a class="markdownIt-Anchor" href="#11132-重新指定构建项目的方式"></a> 11.13.2 重新指定构建项目的方式</h5><table><thead><tr><th style="text-align:center">根据标签构建项目</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588696879059.png" alt="1588696879059"></td></tr></tbody></table><table><thead><tr><th style="text-align:center">自定义构建</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588697752850.png" alt="1588697752850"></td></tr></tbody></table><h5 id="11133-构建项目成功后需要将内容发布到目标服务器"><a class="markdownIt-Anchor" href="#11133-构建项目成功后需要将内容发布到目标服务器"></a> 11.13.3 构建项目成功后，需要将内容发布到目标服务器</h5><table><thead><tr><th style="text-align:center">发布服务器后执行的命令</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588697770621.png" alt="1588697770621"></td></tr></tbody></table><h5 id="11134-添加程序代码"><a class="markdownIt-Anchor" href="#11134-添加程序代码"></a> 11.13.4 添加程序代码</h5><blockquote><p>指定目标服务器的Dockerfile以及docker-compose.yml文件。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 文件</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">testcd-1.0-SNAPSHOT.war</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose.yml文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  testcd:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">testcd</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8081</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h5 id="11135-测试"><a class="markdownIt-Anchor" href="#11135-测试"></a> 11.13.5 测试</h5><blockquote><p>在Jenkins中指定Tag后，Jenkins会从Gitlab拉取指定版本分支，并打包推送到目标服务器。</p></blockquote><table><thead><tr><th style="text-align:center">根据标签修改发布版本</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qgw3wcroi.hn-bkt.clouddn.com/1588700462690.png" alt="1588700462690"></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:59 GMT+0000 (GMT) --&gt;&lt;p&gt;&lt;img src=&quot;http://qgw3wcroi.hn-bkt.clouddn.com/1586333742105.png&quot; alt=&quot;15863337
      
    
    </summary>
    
      <category term="微服务" scheme="yihao.ml/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Docker" scheme="yihao.ml/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Wow 插件开发-清理背包插件</title>
    <link href="yihao.ml/2020/07/24/2020%E2%80%9307-24-Wow%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>yihao.ml/2020/07/24/2020–07-24-Wow 插件开发/</id>
    <published>2020-07-24T11:49:00.000Z</published>
    <updated>2020-12-01T12:12:50.359Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p><video src="http://qgw3wcroi.hn-bkt.clouddn.com/7mQ5-4zp4XoZ6kT3cSku-ig.gif.mp4" controls></video></p><p>在对话框中输入 “/delete [轻弹丸]” 回车即可删除轻弹丸,有了这个就可以方便的删除掉背包的任意垃圾</p><h3 id="1安装ide"><a class="markdownIt-Anchor" href="#1安装ide"></a> 1.安装IDE</h3><p>编辑器这里我推荐用sublime，因为它可以装格式化lua 代码插件，而且高亮显示关键字。如果你喜欢用Notepad++,Vscode，Editplus也无所谓，选择一个自己喜欢的。</p><p>Sublime3 [<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a>]</p><h3 id="2编写plugin"><a class="markdownIt-Anchor" href="#2编写plugin"></a> 2.编写Plugin</h3><p>打开Sublime 3</p><p>执行：File -&gt; Open Folder ，选择WOW插件目录\World of Warcraft_classic_\Interface\AddOns</p><p>打开目录以后,创建一个MyDelete的目录，并在目录下创建两个文件MyDelete.toc和MyDelete.lua。</p><p>下面我们开始写代码,用的语言是Lua</p><p>第一个MyDelete.toc中包含了我们的插件描述信息，其中包含标题、作者、版本号、备注、lua脚本连接等，具体代码如下：</p><p>MyDelete.toc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## Interface: 32999</span><br><span class="line">## Title: MyDelete</span><br><span class="line">## Author: zyh</span><br><span class="line">## Version: 0.1</span><br><span class="line">## Notes: 自动清理背包</span><br><span class="line">## DefaultState: Enabled</span><br><span class="line">## LoadOnDemand: 0</span><br><span class="line">## SavedVariables:</span><br><span class="line">MyDelete.lua</span><br></pre></td></tr></table></figure><p>第二个MyDelete.lua 中包含了我们的核心代码部分，核心思想如下:</p><ul><li>Drop函数，注册/delete 指令</li><li>DeleteItemAction函数，是/delete 指令触发的函数，其核心思路是：遍历背包中的所有solt(槽)，匹配待删除物品，检测到物品以后使用PickupContainerItem和DeleteCursorItem两个API来丢弃物品</li><li>GetItemName函数，获取 Item Hyperlink (物品超链接)中的Item Name (物品名称)，这边Item Name和Item Hyperlink是两个概念。</li></ul><p>MyDelete.lua</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Drop()</span><br><span class="line"></span><br><span class="line">    SlashCmdList[&quot;DeleteItem&quot;] = DeleteItemAction</span><br><span class="line">    SLASH_DeleteItem1 = &quot;/delete&quot;</span><br><span class="line">    print(&quot;MyDelete load finish&quot;)</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function GetItemName(item)</span><br><span class="line"></span><br><span class="line">    itemName, itemLink, itemRarity, itemLevel, itemMinLevel, itemType, itemSubType, itemStackCount, itemEquipLoc, itemIcon, </span><br><span class="line">    itemSellPrice, itemClassID, itemSubClassID, bindType, expacID, itemSetID, isCraftingReagent = GetItemInfo(item)</span><br><span class="line">    </span><br><span class="line">    return itemName</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function DeleteItemAction(item)</span><br><span class="line">    if item == &quot;&quot; then return end</span><br><span class="line"></span><br><span class="line">    name = GetItemName(item)</span><br><span class="line">    for b = 0, 4 do</span><br><span class="line">        p = GetContainerNumSlots(b)</span><br><span class="line">        for i = 1, p do</span><br><span class="line">            e = GetContainerItemLink(b, i)</span><br><span class="line">            if e and string.find(e, name) then</span><br><span class="line">                PickupContainerItem(b, i);</span><br><span class="line">                DeleteCursorItem();</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local frame = CreateFrame(&quot;Frame&quot;, nil, UIParent);</span><br><span class="line">frame:RegisterEvent(&quot;VARIABLES_LOADED&quot;);</span><br><span class="line">frame:SetScript(&quot;OnEvent&quot;, Drop);</span><br></pre></td></tr></table></figure><p>将两个核心文件放到AddOns/MyDelete目录下，重启WOW。进入游戏以后，先看一下“综合”频道有没有打出“MyDelete load finish”等字样，如果有，则插件已经生效。</p><p>如果你是粘贴的我的代码，你应该已经看到了“MyDelete load finish”</p><h3 id="3测试"><a class="markdownIt-Anchor" href="#3测试"></a> 3.测试</h3><p>下面我们来删除一些东西测试一下，<font color="red">请在操作之前务必用自己的小号或者腾空自己的背包</font>，不然删掉一些重要物品就玩大了。</p><p>到商店卖一些轻弹丸和重弹丸，或者找点便宜的道具。 输入<code>/delete</code> 在后面跟上轻弹丸的超链接(shift + 鼠标左键)，然后回车查看效果</p><h3 id="4其他"><a class="markdownIt-Anchor" href="#4其他"></a> 4.其他</h3><p>下面附上wow api地址，想了解的看一下<br>:[<a href="http://wowprogramming.com/docs/api.html" target="_blank" rel="noopener">http://wowprogramming.com/docs/api.html</a>]</p><p>想给Sublime安装格式化LUA代码工具，连接地址:[<a href="https://github.com/Koihik/LuaFormatter" target="_blank" rel="noopener">https://github.com/Koihik/LuaFormatter</a>]</p><p>有朋友跟我反应不想用超链接删除物品，喜欢打字，其实也好改，只需要该DeleteItemAction函数即可，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function DeleteItemAction(item)</span><br><span class="line"></span><br><span class="line">    if item == &quot;&quot; then return end</span><br><span class="line"></span><br><span class="line">    --name = GetItemName(item)</span><br><span class="line">    for b = 0, 4 do</span><br><span class="line">        p = GetContainerNumSlots(b)</span><br><span class="line">        for i = 1, p do</span><br><span class="line">            e = GetContainerItemLink(b, i)</span><br><span class="line">            if e and string.find(e, item ) then</span><br><span class="line">                PickupContainerItem(b, i);</span><br><span class="line">                DeleteCursorItem();</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样改好以后输入/rl 重新加载，输入 &quot;/delete 轻弹丸 &quot;查看效果</p><p>Tips：可以结合宏一起使用比如我这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/delete 加固的宝箱</span><br><span class="line">/delete 新鲜的大鱼</span><br><span class="line">/delete 巨型蚌壳</span><br><span class="line">/delete 21磅重的龙虾</span><br><span class="line">/delete 12磅重的龙虾</span><br><span class="line">/delete 9磅重的龙虾</span><br><span class="line">/delete 7磅重的龙虾</span><br></pre></td></tr></table></figure><p><a href="https://bbs.nga.cn/read.php?&amp;tid=22813671" target="_blank" rel="noopener">https://bbs.nga.cn/read.php?&amp;tid=22813671</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;&lt;video src=&quot;http://qgw3wcroi.hn-bkt.clouddn.com/7mQ5-4zp4XoZ6kT3cSku-ig.gif.mp
      
    
    </summary>
    
      <category term="游戏开发" scheme="yihao.ml/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Wow" scheme="yihao.ml/tags/Wow/"/>
    
  </entry>
  
  <entry>
    <title>KNN</title>
    <link href="yihao.ml/2020/02/08/2020-02-18-k%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>yihao.ml/2020/02/08/2020-02-18-k最近邻算法/</id>
    <published>2020-02-08T23:25:23.000Z</published>
    <updated>2020-12-01T12:12:50.358Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>KNN是监督学习中解决分类问题的一种算法，又叫 K-Nearest Neighbor也叫K近邻算法。</p><p>它的一个基本思路是：如果一个样本在特征空间中，K个最近邻的样本中的大多数属于某一类型，那么这个样本也划分为这个类型。我们可以结合下图（图源自WIKI）。来进一步了解一下它是如何对样本点进行分类的。</p><p><img src="https://i.loli.net/2020/02/18/b1tvMYDg9p6INJO.png" alt="330px-KnnClassification.svg.png"></p><p>在图示中有两种点，一种蓝色正方形，一种红色三角形，那么现在请问绿色的圆形点会被分到哪一类？</p><p>情况一： 假定，找3个(K)离圆点最近的点。是蓝色正方形的概率为1/3；是红色三角形的概率为2/3。那么该点就是红色三角形这一类。</p><p>情况二： 假定，找5个(K)离圆点最近的点。是蓝色正方形的概率为3/5；是红色三角形的概率为2/5，那么该点就是蓝色正方形这一类。</p><p>由此可见，KNN算法中的K对结果的影响还是蛮大的，因此在训练模型阶段要选取一个合适的K值。</p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>1）计算测试数据和个样本数据之间的距离<br>2）按照距离的递增关系排序<br>3）选择距离最小的K个点<br>4）确定前K个点所在类别的出现频率<br>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类</p><h4 id="代码实现步骤"><a class="markdownIt-Anchor" href="#代码实现步骤"></a> 代码实现步骤</h4><h5 id="0引入依赖"><a class="markdownIt-Anchor" href="#0引入依赖"></a> 0.引入依赖</h5><p>这里引入sklearn里的数据集iris，其中有iris.data（150个样本),iris.target（每个样本的分类）</p><p>这里引入skelearn里的train_test_split将iris数据 切分数据集为<code>训练集</code>和<code>测试集</code></p><p>为了判断最终预测结果的好坏，我们使用了sklearn里的accuracy_score函数，它可以方便的计算准确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br></pre></td></tr></table></figure><h5 id="1-数据加载和预处理"><a class="markdownIt-Anchor" href="#1-数据加载和预处理"></a> 1. 数据加载和预处理</h5><p>加载数据集iris，使用pandas中的DataFrame绘制出表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data = iris.data, columns = iris.feature_names)</span><br><span class="line">df[<span class="string">'class'</span>] = iris.target</span><br><span class="line">df[<span class="string">'class'</span>] = df[<span class="string">'class'</span>].map(&#123;<span class="number">0</span>: iris.target_names[<span class="number">0</span>], <span class="number">1</span>: iris.target_names[<span class="number">1</span>], <span class="number">2</span>: iris.target_names[<span class="number">2</span>]&#125;)</span><br><span class="line">df.head(<span class="number">10</span>)</span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure><p>下面划分<code>训练集</code>和<code>测试集</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x为样本点</span></span><br><span class="line">x = iris.data</span><br><span class="line"><span class="comment"># y为预测分类</span></span><br><span class="line">y = iris.target.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">35</span>, stratify=y)</span><br><span class="line"></span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br></pre></td></tr></table></figure><h5 id="2-核心算法实现"><a class="markdownIt-Anchor" href="#2-核心算法实现"></a> 2. 核心算法实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l1_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(np.abs(a-b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 欧几里得距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt( np.sum((a-b) ** <span class="number">2</span>, axis=<span class="number">1</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类器实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">kNN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个初始化方法，__init__ 是类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_neighbors = <span class="number">1</span>, dist_func = l1_distance)</span>:</span></span><br><span class="line">        self.n_neighbors = n_neighbors</span><br><span class="line">        self.dist_func = dist_func</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x_train = x</span><br><span class="line">        self.y_train = y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模型预测方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化预测分类数组</span></span><br><span class="line">        y_pred = np.zeros( (x.shape[<span class="number">0</span>], <span class="number">1</span>), dtype=self.y_train.dtype )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历输入的x数据点，取出每一个数据点的序号i和数据x_test</span></span><br><span class="line">        <span class="keyword">for</span> i, x_test <span class="keyword">in</span> enumerate(x):</span><br><span class="line">            <span class="comment"># x_test跟所有训练数据计算距离</span></span><br><span class="line">            distances = self.dist_func(self.x_train, x_test)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 得到的距离按照由近到远排序，取出索引值</span></span><br><span class="line">            nn_index = np.argsort(distances)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选取最近的k个点，保存它们对应的分类类别</span></span><br><span class="line">            nn_y = self.y_train[ nn_index[:self.n_neighbors] ].ravel()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 统计类别中出现频率最高的那个，赋给y_pred[i]</span></span><br><span class="line">            y_pred[i] = np.argmax( np.bincount(nn_y) )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><h5 id="3-测试"><a class="markdownIt-Anchor" href="#3-测试"></a> 3. 测试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个knn实例</span></span><br><span class="line">knn = kNN()</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果list</span></span><br><span class="line">result_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对不同的参数选取，做预测</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">    knn.dist_func = l1_distance <span class="keyword">if</span> p == <span class="number">1</span> <span class="keyword">else</span> l2_distance</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 考虑不同的k取值，步长为2</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">        knn.n_neighbors = k</span><br><span class="line">        <span class="comment"># 传入测试数据，做预测</span></span><br><span class="line">        y_pred = knn.predict(x_test)</span><br><span class="line">        <span class="comment"># 求出预测准确率</span></span><br><span class="line">        accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">        result_list.append([k, <span class="string">'l1_distance'</span> <span class="keyword">if</span> p == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'l2_distance'</span>, accuracy])</span><br><span class="line">df = pd.DataFrame(result_list, columns=[<span class="string">'k'</span>, <span class="string">'距离函数'</span>, <span class="string">'预测准确率'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>最终结果如下图所示：</p><p><img src="https://i.loli.net/2020/02/18/DUvoZNPylTkWz9H.png" alt="result.png"></p><p>选择欧几里得距离 K=5,7,9和选择曼哈顿距离 k=5 取得的效果最好！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;KNN是监督学习中解决分类问题的一种算法，又叫 K-Nearest Neighbor也叫K近邻算法。&lt;/p&gt;&lt;p&gt;它的一个基本思路是：如果一个样本在特征空间
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性回归(最小二乘法)</title>
    <link href="yihao.ml/2020/02/08/2020-02-08-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)/"/>
    <id>yihao.ml/2020/02/08/2020-02-08-线性回归(最小二乘法)/</id>
    <published>2020-02-08T23:25:23.000Z</published>
    <updated>2020-12-01T12:12:50.358Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>前面介绍过线性回归，并使用了R语言实现了训练模型，完成了通过水的沸点来估计海拔高度的预测。<a href="http://yihao.ml/2018/10/07/2018-10-07-%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/">链接</a></p><p>R语言封装了最小二乘法的具体实现。我们在调用时对其内部细节感触并不是很深，下面使用python实现 最小二乘法，加深对模型训练的理解。</p><p>0.导入数据</p><p>我们还是用前面准备好的数据,保存成a.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">194.5,131.79</span><br><span class="line">194.3,131.79</span><br><span class="line">197.9,135.02</span><br><span class="line">198.4,135.55</span><br><span class="line">199.4,136.46</span><br><span class="line">199.9,136.83</span><br><span class="line">200.9,137.82</span><br><span class="line">201.1,138.00</span><br><span class="line">201.4,138.06</span><br><span class="line">201.3,138.05</span><br><span class="line">203.6,140.04</span><br><span class="line">204.6,142.44</span><br><span class="line">209.5,145.47</span><br><span class="line">208.6,144.34</span><br><span class="line">210.7,146.30</span><br><span class="line">211.9,147.54</span><br><span class="line">212.2,147.80</span><br></pre></td></tr></table></figure><p>编写python的<code>numpy</code>和<code>matplotlib.pyplot</code>，读取a.csv并且画出所有点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="string">'/tmp/a.csv'</span></span><br><span class="line">array = np.genfromtxt(f,delimiter=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line">x = array[:,<span class="number">0</span>]</span><br><span class="line">y = array[:,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,c=<span class="string">'r'</span>)</span><br><span class="line">plt.show</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/08/bGNWdanpXxow5Rl.png" alt="1.png"></p><p>1.实现算法</p><p>下面定义一个fit方法，实现模型训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设函数为y=ax+b 求出a,b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(x,y)</span>:</span></span><br><span class="line">  sum_xy = <span class="number">0</span></span><br><span class="line">  sum_x = <span class="number">0</span></span><br><span class="line">  sum_y = <span class="number">0</span></span><br><span class="line">  sum_x2 = <span class="number">0</span></span><br><span class="line">  n = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    sum_xy += x[i]*y[i]</span><br><span class="line">    sum_x += x[i]</span><br><span class="line">    sum_y += y[i]</span><br><span class="line">    sum_x2 += x[i] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  a = ((sum_xy/n) - (sum_x/n) * (sum_y/n)) / ((sum_x2/n) - (sum_x/n) * (sum_x/n))</span><br><span class="line">  b = (sum_y/n) - (a * (sum_x/n))</span><br><span class="line">  <span class="keyword">return</span> a,b</span><br></pre></td></tr></table></figure><p>为了方便看误差，我们定义计算损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(a,b,points)</span>:</span></span><br><span class="line">  x = points[:,<span class="number">0</span>]</span><br><span class="line">  y = points[:,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  pred_y = a * x + b</span><br><span class="line">  n = y.shape[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    total += math.fabs(y[i] - pred_y[i])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><p>2.测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用fit方法完成模型训练</span></span><br><span class="line">a,b = fit(x,y)</span><br><span class="line"><span class="comment"># 计算模型 误差</span></span><br><span class="line">cost = compute(a,b,array)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"a is: "</span>, a)</span><br><span class="line">print(<span class="string">"b is: "</span>, b)</span><br><span class="line">print(<span class="string">"cost is: "</span>, cost)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画散点图</span></span><br><span class="line">plt.scatter(x,y,c=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对指定的x画出预测的Y，画直线</span></span><br><span class="line">pred_y = a * x + b</span><br><span class="line">plt.plot(x,pred_y,c=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/08/cM7DljBuhHJVo8z.png" alt="2.png"></p><p>我们发现算出来的斜率是0.8954625247967952,截距是-42.130870767876615</p><p>与R已封装的包，算得的结果很接近，这也证明了写的代码没啥问题！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;前面介绍过线性回归，并使用了R语言实现了训练模型，完成了通过水的沸点来估计海拔高度的预测。&lt;a href=&quot;http://yihao.ml/2018/10/
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>K-Means</title>
    <link href="yihao.ml/2020/02/06/2020%E2%80%9302-06-K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/"/>
    <id>yihao.ml/2020/02/06/2020–02-06-K均值聚类/</id>
    <published>2020-02-06T16:28:22.000Z</published>
    <updated>2020-12-01T12:12:50.358Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>机器学习三大类，监督学习、无监督学习和强化学习。K均值(K-Means)是无监督学习中的一种聚类算法，能有有效的将数据划分子类。</p><p><img src="https://i.loli.net/2020/02/06/pYcgJ8LtbiWRCBk.gif" alt="K-means_convergence.gif"></p><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h4><p>打开新浪新闻首页，可以发现“要闻”一栏展示了目前最热门的一组新闻。类似的还有google news等</p><p><img src="https://i.loli.net/2020/02/06/dbgT9k2hpSnvHY5.png" alt="xlxw.png"></p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>以二维数据为例，描述一下k-means的实现思路：</p><pre><code>1. 在二维平面区域内n个样本点中，首先任意选取m个点，称其为质心点2. 对n个样本点和m个质心点求距离（欧式距离），找到每个样本点离得最近的质心点3. 更新m个质心点的位置，重复第2步</code></pre><p>以下图为例，描述详细的划分流程</p><p><img src="https://i.loli.net/2020/02/06/NRheVH1ZnaBLw4A.png" alt="6step.png"></p><pre><code>1. 在平面内n个样本点中，选2个质心点标记好x，对应b)2. 分别对n个样本点和2个质心点求距离，找到每个样本点离得最近的质心点;对应图c)  3. 更新2个质心点的位置对应图d)4. 重复第2步，找到每个样本点离得最近的质心点;对应图e)5. 重复第2步，找到每个样本点离得最近的质心点;对应图f)</code></pre><p>下面使用Python语言实现模型训练和预测，其中会使用到 <code>numpy</code>、<code>matplotlib.pyplot</code>、<code>sklearn.datasets</code>、<code>scipy.spatial.distance</code>，不熟悉的童鞋自行先去补一下，看起来事半功倍！</p><h5 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h5><p>思路：使用<code>sklearn.datasets</code>提供的数据来训练出模型。然后使用训练出的模型进行预测并验证模型的正确性！</p><p>引入依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br></pre></td></tr></table></figure><p>初始化数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 是n个样本点</span></span><br><span class="line"><span class="comment"># y 是每个样本点对应的质心点</span></span><br><span class="line">x, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">6</span>, random_state=<span class="number">1234</span>, cluster_std=<span class="number">0.6</span>)</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line"><span class="comment">#print(y)</span></span><br></pre></td></tr></table></figure><p>为了方便观察，我们画出图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>], c=y)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/06/WlrCbpR1dzGgwLF.png" alt="csh.png"></p><p>编写核心k-means代码，封装一个类K_Means</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K_Means</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，参数n_clusters(k), 迭代次数max_iter ,初始质心 centroids</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n_cluster=<span class="number">6</span>,n_iters=<span class="number">300</span>,centeroids=[])</span>:</span></span><br><span class="line">self.n_cluster = n_cluster</span><br><span class="line">self.n_iters = n_iters</span><br><span class="line">self.centeroids = centeroids</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self,data)</span>:</span></span><br><span class="line"><span class="comment"># 1. 计算每个样本点和样每个质心点欧式距离</span></span><br><span class="line">distances = cdist(data,self.centeroids)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将distances排序，找到最小的那个距离的下标</span></span><br><span class="line">c_ind = np.argmin(distances,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 对每一类数据进行均值计算，更新质心点位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> self.n_cluster:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> c_ind:</span><br><span class="line">self.centeroids[i] = np.mean(data[ c_ind == i ],axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,samples)</span>:</span></span><br><span class="line">distances = cdist(samples,self.centeroids)</span><br><span class="line"><span class="keyword">return</span> np.argmin(distances,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>测试,为了方便观察我们先封装一个画子图方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画子图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotKMeans</span><span class="params">(x,y,centroids,subplot,title)</span>:</span></span><br><span class="line">  <span class="comment"># 分配子图 121表示1行2列的子图中的第一个</span></span><br><span class="line">  plt.subplot(subplot)</span><br><span class="line">  plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>],c=<span class="string">'r'</span>)</span><br><span class="line">  <span class="comment"># 画出质心点</span></span><br><span class="line">  plt.scatter(centroids[:,<span class="number">0</span>],centroids[:,<span class="number">1</span>],c=np.array(range(<span class="number">6</span>)),s=<span class="number">100</span>)</span><br><span class="line">  plt.title(title)</span><br><span class="line"></span><br><span class="line">kmeans = K_Means(max_iter=<span class="number">300</span>,centroids=np.array([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">6</span>))</span><br><span class="line">plotKMeans(x,y,kmeans.centroids,<span class="number">121</span>,<span class="string">'Init State'</span>)</span><br><span class="line"><span class="comment"># 开始聚类</span></span><br><span class="line">kmeans.fit(x)</span><br><span class="line">plotKMeans(x,y,kmeans.centroids,<span class="number">122</span>,<span class="string">'Final State'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测新数据[0,0]和[10,7]的类别</span></span><br><span class="line">x_new = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">10</span>,<span class="number">7</span>]])</span><br><span class="line">y_pred = kmeans.predict(x_new)</span><br><span class="line"><span class="comment"># 打印预测出的类别</span></span><br><span class="line">print(y_pred)</span><br><span class="line"><span class="comment"># 质心点在二维坐标轴的位置</span></span><br><span class="line">print(kmeans.centroids)</span><br><span class="line"></span><br><span class="line">plt.scatter(x_new[:,<span class="number">0</span>],x_new[:,<span class="number">1</span>],s=<span class="number">100</span>,c=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/06/qyoJAdVfBbZxpeS.png" alt="end.png"></p><p>预测的结果是[0,0]属于1; [10,7]属于5，1对应的群组是质心点[-2,0]所在的群组，而5对应的群组是质心点[9,7]所在的群组，显然是正确的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;机器学习三大类，监督学习、无监督学习和强化学习。K均值(K-Means)是无监督学习中的一种聚类算法，能有有效的将数据划分子类。&lt;/p&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="机器学习" scheme="yihao.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="k-means" scheme="yihao.ml/tags/k-means/"/>
    
  </entry>
  
  <entry>
    <title>八皇后</title>
    <link href="yihao.ml/2019/12/15/2019%E2%80%9312-15-%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <id>yihao.ml/2019/12/15/2019–12-15-八皇后/</id>
    <published>2019-12-15T17:00:00.000Z</published>
    <updated>2020-12-01T12:12:50.356Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法?</p><p><img src="https://i.loli.net/2019/12/15/9ckTeuAQVwG1Rz7.jpg" alt="BF54C6BB-1CB9-4408-8438-95BC7819F8A8.jpeg"></p><p>在上个世纪，计算机不发达的时候，这个问题困惑着所有人。现在已经有相关算法算出最终结果是92种摆法。</p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>1.第一个皇后先放第一行第一列</p><p>2.第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p><p>3.继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p><p>4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p><p>5.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123; </span><br><span class="line"><span class="comment">//定义一个 max 表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//定义数组 array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//测试一把 ， 8 皇后是否正确</span></span><br><span class="line">Queue8 queue8 = <span class="keyword">new</span> Queue8(); </span><br><span class="line">queue8.check(<span class="number">0</span>); </span><br><span class="line">System.out.printf(<span class="string">"一共有%d 解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d 次"</span>, judgeCount); </span><br><span class="line"><span class="comment">// 1.5w </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//编写一个方法，放置第 n 个皇后</span></span><br><span class="line"><span class="comment">//特别注意： check 是 每一次递归时，进入到 check 中都有for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span>(n == max) &#123; </span><br><span class="line"><span class="comment">//n = 8 , 其实 8 个皇后就既然放好</span></span><br><span class="line">print(); </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123; </span><br><span class="line"><span class="comment">//先把当前这个皇后 n , 放到该行的第 1 列</span></span><br><span class="line">array[n] = i; </span><br><span class="line"><span class="comment">//判断当放置第 n 个皇后到 i 列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(judge(n)) &#123; </span><br><span class="line"><span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">//接着放 n+1 个皇后,即开始递归</span></span><br><span class="line">check(n+<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第 n 个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当我们放置第 n 个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 表示第 n 个皇后</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">judgeCount++; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">//1. array[i] == array[n] 表示判断 第 n 个皇后是否和前面的 n-1 个皇后在同一列</span></span><br><span class="line"><span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜线</span></span><br><span class="line"><span class="comment">// n = 1 放置第 2 列 1 n = 1 array[1] = 1 </span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 </span></span><br><span class="line"><span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">count++; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; </span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Dec 01 2020 12:12:58 GMT+0000 (GMT) --&gt;&lt;p&gt;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="yihao.ml/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="递归" scheme="yihao.ml/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
